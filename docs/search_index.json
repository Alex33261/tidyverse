[
["index.html", "Introduction à R et au tidyverse À propos de ce document", " Introduction à R et au tidyverse Julien Barnier 2017-10-12 À propos de ce document Ce document est une introduction à l’utilisation du logiciel libre de traitement de données et d’analyse statistiques R. Il se veut le plus accessible possible, y compris pour ceux qui ne sont pas particulièrement familiers avec l’informatique. Il se base à la fois sur les fonctionnalités de R “de base”, et sur une série d’extensions de plus en plus populaires regroupées sous l’appellation tidyverse. Par contre, ce document n’est pas une introduction aux méthodes statistiques. Il est basé sur R version 3.4.2 (2017-09-28). Ce document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse : https://juba.github.io/tidyverse Le code source est disponible sur GitHub. Pour toute suggestion ou correction, il est possible de me contacter par mail ou sur Twitter. Remerciements Toute la première partie de ce document est tirée d’un précédent document Introduction à R qui a bénéficié de la relecture et des enrichissements de Mayeul Kauffmann, Julien Biaudet, Frédérique Giraud, Joël Gombin, Milan Bouchet-Valat et Joseph Larmarange. Ce document est généré par l’excellente extension bookdown de Yihui Xie. Licence Ce document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International. Licence Creative Commons "],
["01-presentation.html", "Partie 1 Présentation 1.1 À propos de R 1.2 À propos de RStudio 1.3 À propos du tidyverse 1.4 Structure du document 1.5 Prérequis", " Partie 1 Présentation 1.1 À propos de R R est un langage orienté vers le traitement et l’analyse quantitative de données, dérivé du langage . Il est développé depuis les années 90 par un groupe de volontaires de différents pays et par une large communauté d’utilisateurs. C’est un logiciel libre, publié sous licence GNU GPL. L’utilisation de R présente plusieurs avantages : c’est un logiciel multiplateforme, qui fonctionne aussi bien sur des sytèmes Linux, Mac OS X ou Windows c’est un logiciel libre, développé par ses utilisateurs, diffusable etmodifiable par tout un chacun c’est un logiciel gratuit c’est un logiciel très puissant, dont les fonctionnalités de base peuvent être étendues à l’aide d’extensions développées par la communauté. Il en existe plusieurs milliers c’est un logiciel dont le développement est très actif et dont la communauté d’utilisateurs et l’usage ne cessent de s’agrandir c’est un logiciel avec d’excellentes capacités graphiques Comme rien n’est parfait, on peut également trouver quelques inconvénients : le logiciel, la documentation de référence et les principales ressources sont en anglais. Il est toutefois parfaitement possible d’utiliser R sans spécialement maîtriser cette langue et il existe de plus en plus de ressources francophones. R n’est pas un logiciel au sens classique du terme, mais plutôt un langage de programmation. Il fonctionne à l’aide de scripts (des petits programmes) édités et exécutés au fur et à mesure de l’analyse. Ce point, qui peut apparaître comme un gros handicap, s’avère après un temps d’apprentissage être un mode d’utilisation d’une grande souplesse. en tant que langage de programmation, R a la réputation d’être difficile d’accès, notamment pour ceux n’ayant jamais programmé auparavant. Ce document ne demande aucun prérequis en informatique ou en programmation. Juste un peu de motivation pour l’apprentissage du langage et, si possible, des données intéressantes sur lesquelles appliquer les connaissances acquises. L’aspect langage de programmation et la difficulté qui en découle peuvent sembler des inconvénients importants. Le fait de structurer ses analyses sous forme de scripts (suite d’instructions effectuant les différentes opérations d’une analyse) présente cependant de nombreux avantages : le script garde par ordre chronologique l’ensemble des étapes d’une analyse, de l’importation des données à leur analyse en passant par les manipulations et les recodages on peut à tout moment revenir en arrière et modifier ce qui a été fait il est très rapide de réexécuter une suite d’opérations complexes on peut très facilement mettre à jour les résultats en cas de modification des données sources le script garantit, sous certaines conditions, la reproductibilité des résultats obtenus 1.2 À propos de RStudio RStudio n’est pas à proprement parler une interface graphique pour R, il s’agit plutôt d’un environnement de développement intégré, qui propose des outils et facilite l’écriture de scripts et l’usage de R au quotidien. C’est une interface bien supérieure à celles fournies par défaut lorsqu’on installe R sous Windows ou sous Mac1. Pour paraphraser Hadrien Commenges, il n’y a pas d’obligation à utiliser RStudio, mais il y a une obligation à ne pas utiliser les interfaces de R par défaut. RStudio est également un logiciel libre et gratuit. Une version payante existe, mais elle ne propose pas de fonctionnalités indispensables. 1.3 À propos du tidyverse Le tidyverse est un ensemble d’extensions pour R (code développé par la communauté permettant de rajouter des fonctionnalités à R) construites autour d’une philosophie commune et conçues pour fonctionner ensemble. Elles facilitent l’utilisation de R dans les domaines les plus courants : manipulation des données, recodages, production de graphiques, etc. La deuxième partie de ce document est entièrement basée sur les extensions du tidyverse, qui est présenté plus en détail chapitre 6. 1.4 Structure du document Ce document est composé de deux grandes parties : Une Introduction à R, qui présente les bases du langage R et de l’interface RStudio Une Introduction au tidyverse qui présente cet ensemble d’extensions pour la visualisation, la manipulation des données et l’export de résultats Les personnes déjà familières avec R “de base” peuvent sauter toute la partie Introduction à R et passer directement à l’Introduction au tidyverse. 1.5 Prérequis Le seul prérequis pour suivre ce document est d’avoir installé R et RStudio sur votre ordinateur. Il s’agit de deux logiciels libres, gratuits, téléchargeables en ligne et fonctionnant sous PC, Mac et Linux. Pour installer R, il suffit de se rendre sur une des pages suivantes2 : Installer R sous Windows Installer R sous Mac Pour installer RStudio, rendez-vous sur la page suivante et téléchargez la version adaptée à votre système : https://www.rstudio.com/products/rstudio/download/#download Sous Linux R n’est fourni que comme un outil en ligne de commande.↩ Sous Linux, utilisez votre gestionnaire de packages habituel.↩ "],
["02-prise_en_main.html", "Partie 2 Prise en main 2.1 La console 2.2 Objets 2.3 Fonctions 2.4 Regrouper ses commandes dans des scripts 2.5 Installer et charger des extensions (packages) 2.6 Exercices", " Partie 2 Prise en main Une fois R et RStudio installés sur votre machine, nous n’allons pas lancer R mais plutôt RStudio. RStudio n’est pas à proprement parler une interface graphique qui permettrait d’utiliser R de manière “classique” via la souris, des menus et des boîtes de dialogue. Il s’agit plutôt de ce qu’on appelle un Environnement de développement intégré (IDE) qui facilite l’utilisation de R et le développement de scripts (voir section 1.2). 2.1 La console 2.1.1 L’invite de commandes Au premier lancement de RStudio, l’écran principal est découpé en trois grandes zones : Interface de Rstudio La zone de gauche se nomme Console. À son démarrage, RStudio a lancé une nouvelle session de R et c’est dans cette fenêtre que nous allons pouvoir interagir avec lui. La Console doit normalement afficher un texte ressemblant à ceci : R version 3.4.2 (2017-09-28) -- &quot;Short Summer&quot; Copyright (C) 2017 The R Foundation for Statistical Computing Platform: x86_64-pc-linux-gnu (64-bit) R est un logiciel libre livré sans AUCUNE GARANTIE. Vous pouvez le redistribuer sous certaines conditions. Tapez &#39;license()&#39; ou &#39;licence()&#39; pour plus de détails. R est un projet collaboratif avec de nombreux contributeurs. Tapez &#39;contributors()&#39; pour plus d&#39;information et &#39;citation()&#39; pour la façon de le citer dans les publications. Tapez &#39;demo()&#39; pour des démonstrations, &#39;help()&#39; pour l&#39;aide en ligne ou &#39;help.start()&#39; pour obtenir l&#39;aide au format HTML. Tapez &#39;q()&#39; pour quitter R. suivi d’une ligne commençant par le caractère &gt; et sur laquelle devrait se trouver votre curseur. Cette ligne est appelée l’invite de commande (ou prompt en anglais). Elle signifie que R est disponible et en attente de votre prochaine commande. Nous pouvons tout de suite lui fournir une première commande, en saisissant le texte suivant puis en appuyant sur Entrée : 2 + 2 [1] 4 R nous répond immédiatement, et nous pouvons constater avec soulagement qu’il sait faire des additions à un chiffre3. On peut donc continuer avec d’autres opérations : 5 - 7 [1] -2 4 * 12 [1] 48 -10 / 3 [1] -3.333333 5^2 [1] 25 Cette dernière opération utilise le symbole ^ qui représente l’opération puissance. 5^2 signifie donc “5 au carré”, soit 25. 2.1.2 Précisions et astuces concernant la saisie des commandes Lorsqu’on saisit une commande, les espaces autour des opérateurs n’ont pas d’importance. Les trois commandes suivantes sont donc équivalentes, mais on privilégie en général la deuxième pour des raisons de lisibilité du code. 10+2 10 + 2 10 + 2 Quand vous êtes dans la console, vous pouvez utiliser les flèches vers le haut et vers le bas pour naviguer dans l’historique des commandes que vous avez tapées précédemment. Vous pouvez à tout moment modifier la commande affichée, et l’exécuter en appuyant sur Entrée. Enfin, il peut arriver qu’on saisisse une commande de manière incomplète : oubli d’une parenthèse, faute de frappe, etc. Dans ce cas, R remplace l’invite de commande habituel par un signe + : 4 * + Cela signifie qu’il “attend la suite”. On peut alors soit compléter la commande sur cette nouvelle ligne et appuyer sur Entrée, soit, si on est perdu, tout annuler et revenir à l’invite de commandes normal en appuyant sur Esc ou Échap. 2.2 Objets 2.2.1 Objets simples Faire des calculs c’est bien, mais il serait intéressant de pouvoir stocker un résultat quelque part pour pouvoir le réutiliser ultérieurement sans avoir à faire du copier/coller. Pour conserver le résultat d’une opération, on peut le stocker dans un objet à l’aide de l’opérateur d’assignation &lt;-. Cette “flèche” stocke ce qu’il y a à sa droite dans un objet dont le nom est indiqué à sa gauche. Prenons tout de suite un exemple : x &lt;- 2 Cette commande peut se lire “prend la valeur 2 et mets la dans un objet qui s’appelle x”. Si on exécute une commande comportant juste le nom d’un objet, R affiche son contenu : x [1] 2 On voit donc que notre objet x contient bien la valeur 2. On peut évidemment réutiliser cet objet dans d’autres opérations. R le remplacera alors par sa valeur : x + 4 [1] 6 On peut créer autant d’objets qu’on le souhaite. x &lt;- 2 y &lt;- 5 resultat &lt;- x + y resultat [1] 7 Les noms d’objets peuvent contenir des lettres, des chiffres, les symboles . et _. Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d’objets, ce qui signifie que x et X seront deux objets différents, tout comme resultat et Resultat. De manière générale, il est préférable d’éviter les majuscules (pour les risques d’erreur) et les caractères accentués (pour des questions d’encodage) dans les noms d’objets. De même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l’objet, ce qu’il contient) et sa longueur. Par exemple, on préfèrera comme nom d’objet taille_conj1 à taille_du_conjoint_numero_1 ou à t1. Quand on assigne une nouvelle valeur à un objet déjà existant, la valeur précédente est perdue. Les objets n’ont pas de mémoire. x &lt;- 2 x &lt;- 5 x [1] 5 De la même manière, assigner un objet à un autre ne crée pas de “lien” entre les deux. Cela copie juste la valeur de l’objet de droite dans celui de gauche : x &lt;- 1 y &lt;- 3 x &lt;- y x [1] 3 y &lt;- 4 x [1] 3 On le verra, les objets peuvent contenir tout un tas d’informations. Jusqu’ici on n’a stocké que des nombres, mais ils peuvent aussi contenir des chaînes de caractères (du texte), qu’on délimite avec des guillemets simples ou doubles (' ou &quot;) : chien &lt;- &quot;Chihuahua&quot; chien [1] &quot;Chihuahua&quot; 2.2.2 Vecteurs Imaginons maintenant qu’on a demandé la taille en centimètres de 5 personnes et qu’on souhaite calculer leur taille moyenne. On pourrait créer autant d’objets que de tailles et faire l’opération mathématique qui va bien : taille1 &lt;- 156 taille2 &lt;- 164 taille3 &lt;- 197 taille4 &lt;- 147 taille5 &lt;- 173 (taille1 + taille2 + taille3 + taille4 + taille5) / 5 [1] 167.4 Cette manière de faire n’est évidemment pas pratique du tout. On va plutôt stocker l’ensemble de nos tailles dans un seul objet, de type vecteur, avec la syntaxe suivante : tailles &lt;- c(156, 164, 197, 147, 173) Si on affiche le contenu de cet objet, on voit qu’il contient bien l’ensemble des tailles saisies : tailles [1] 156 164 197 147 173 Un vecteur dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre. L’avantage d’un vecteur est que lorsqu’on lui applique une opération, celle-ci s’applique à toutes les valeurs qu’il contient. Ainsi, si on veut la taille en mètres plutôt qu’en centimètres, on peut faire : tailles_m &lt;- tailles / 100 tailles_m [1] 1.56 1.64 1.97 1.47 1.73 Cela fonctionne pour toutes les opérations de base : tailles + 10 [1] 166 174 207 157 183 tailles^2 [1] 24336 26896 38809 21609 29929 Imaginons maintenant qu’on a aussi demandé aux cinq mêmes personnes leur poids en kilos. On peut alors créer un deuxième vecteur : poids &lt;- c(45, 59, 110, 44, 88) On peut alors effectuer des calculs utilisant nos deux vecteurs tailles et poids. On peut par exemple calculer l’indice de masse corporelle (IMC) de chacun de nos enquêtés en divisant leur poids en kilo par leur taille en mètre au carré : imc &lt;- poids / (tailles / 100) ^ 2 imc [1] 18.49112 21.93635 28.34394 20.36189 29.40292 Un vecteur peut contenir des nombres, mais il peut aussi contenir du texte. Imaginons qu’on a demandé aux 5 mêmes personnes leur niveau de diplôme : on peut regrouper l’information dans un vecteur de chaînes de caractères, toujours délimitées par des guillemets simples ou doubles : diplome &lt;- c(&quot;CAP&quot;, &quot;Bac&quot;, &quot;Bac+2&quot;, &quot;CAP&quot;, &quot;Bac+3&quot;) diplome [1] &quot;CAP&quot; &quot;Bac&quot; &quot;Bac+2&quot; &quot;CAP&quot; &quot;Bac+3&quot; L’opérateur :, lui, permet de générer rapidement un vecteur comprenant tous les nombres entre deux valeurs, opération assez courante sous R : x &lt;- 1:10 x [1] 1 2 3 4 5 6 7 8 9 10 Enfin, notons qu’on peut accéder à un élément particulier d’un vecteur en faisant suivre le nom du vecteur de crochets contenant le numéro de l’élément désiré. Par exemple : diplome[2] [1] &quot;Bac&quot; Cette opération, qui utilise l’opérateur [], permet donc la sélection d’éléments d’un vecteur. 2.3 Fonctions 2.3.1 Principe Nous savons désormais effectuer des opérations arithmétiques de base sur des nombres et des vecteurs, et stocker des valeurs dans des objets pour pouvoir les réutiliser plus tard. Pour aller plus loin, nous devons aborder les fonctions qui sont, avec les objets, un deuxième concept de base de R. On utilise des fonctions pour effectuer des calculs, obtenir des résultats et accomplir des actions. Formellement, une fonction a un nom, elle prend en entrée entre parenthèses un ou plusieurs arguments (ou paramètres), et retourne un résultat. Prenons tout de suite un exemple. Si on veut connaître le nombre d’éléments du vecteur tailles que nous avons construit précédemment, on peut utiliser la fonction length, de cette manière : length(tailles) [1] 5 Ici, length est le nom de la fonction, on l’appelle en lui passant un argument entre parenthèses (en l’occurrence notre vecteur tailles), et elle nous renvoit un résultat, à savoir le nombre d’éléments du vecteur passé en paramètre. Autre exemple, la fonction mean calcule et retourne la moyenne d’un vecteur de nombres : mean(tailles) [1] 167.4 Les fonctions min, max et range retournent respectivement les valeurs minimales, maximales et l’étendue d’un vecteur de nombres : min(tailles) [1] 147 max(tailles) [1] 197 range(tailles) [1] 147 197 2.3.2 Arguments Une fonction peut prendre plusieurs arguments, séparés par des virgules. C’est le cas par exemple de la fonction c, déjà vue précédemment4, qui combine l’ensemble de ses arguments en un vecteur : tailles &lt;- c(156, 164, 197, 181, 173) Autre exemple : supposons maintenant que dans notre vecteur tailles nous avons une valeur manquante (une personne a refusé de répondre, ou notre mètre mesureur était en panne). On symbolise celle-ci dans R avec le code interne NA : tailles &lt;- c(156, 164, 197, NA, 173) tailles [1] 156 164 197 NA 173 NA est l’abbréviation de Not available, non disponible. Cette valeur particulière peut être utilisée pour indiquer une valeur manquante, qu’il s’agisse d’un nombre, d’une chaîne de caractères, etc. Si je calcule maintenant la taille moyenne à l’aide de la fonction mean, j’obtiens : mean(tailles) [1] NA En effet, R considère par défaut qu’il ne peut pas calculer la moyenne si une des valeurs n’est pas disponible. Il considère que cette moyenne est elle-même “non disponible” et renvoit donc comme résultat NA. On peut cependant indiquer à mean d’effectuer le calcul en ignorant les valeurs manquantes. Ceci se fait en ajoutant un argument supplémentaire, nommé na.rm (abbréviation de NA remove, “enlever les NA”), et de lui attribuer la valeur TRUE (code interne de R signifiant vrai) : mean(tailles, na.rm = TRUE) [1] 172.5 Positionner le paramètre na.rm à TRUE indique à la fonction mean de ne pas tenir compte des valeurs manquantes dans le calcul. Si on ne dit rien à la fonction mean, cet argument a une valeur par défaut, en l’occurrence FALSE (faux), qui fait qu’il ne supprime pas les valeurs manquantes. Les deux commandes suivantes sont donc rigoureusement équivalentes : mean(tailles) [1] NA mean(tailles, na.rm = FALSE) [1] NA Lorsqu’on passe un argument à une fonction de cette manière, c’est-à-dire sous la forme nom = valeur, on parle d’argument nommé. 2.3.3 Aide sur une fonction Il est fréquent de ne pas savoir (ou d’avoir oublié) quels sont les arguments d’une fonction, ou comment ils se nomment. On peut à tout moment faire appel à l’aide intégrée à R en passant le nom de la fonction (entre guillemets) à la fonction help : help(&quot;mean&quot;) On peut aussi utiliser le raccourci ?mean. Ces deux commandes affichent une page (en anglais) décrivant la fonction, ses paramètres, son résultat, le tout accompagné de diverses notes, références et exemples. Ces pages d’aide contiennent à peu près tout ce que vous pourrez chercher à savoir, mais elles ne sont pas toujours d’une lecture aisée. Dans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide. 2.4 Regrouper ses commandes dans des scripts Jusqu’ici on a utilisé R de manière “interactive”, en saisissant des commandes directement dans la console. Ça n’est cependant pas la manière dont on va utiliser R au quotidien, pour une raison simple : lorsque R redémarre, tout ce qui a été effectué dans la console est perdu. Plutôt que de saisir nos commandes dans la console, on va donc les regrouper dans des scripts (de simples fichiers texte), qui vont garder une trace de toutes les opérations effectuées, et ce sont ces scripts, sauvegardés régulièrement, qui seront le “coeur” de notre travail. C’est en rouvrant les scripts et en réexécutant les commandes qu’ils contiennent qu’on pourra “reproduire” les données, leur traitement, les analyses et leurs résultats. Pour créer un script, il suffit de sélectionner le menu File, puis New file et R script. Une quatrième zone apparaît alors en haut à gauche de l’interface de RStudio. On peut enregistrer notre script à tout moment dans un fichier avec l’extension .R, en cliquant sur l’icône de disquette ou en choissant File puis Save. Un script est un fichier texte brut, qui s’édite de la manière habituelle. À la différence de la console, quand on appuie sur Entrée, cela n’exécute pas la commande en cours mais insère un saut de ligne (comme on pouvait s’y attendre). Pour exécuter une commande saisie dans un script, il suffit de positionner le curseur sur la ligne de la commande en question, et de cliquer sur le bouton Run dans la barre d’outils juste au-dessus de la zone d’édition du script. On peut aussi utiliser le raccourci clavier Ctrl + Entrée (Cmd + Entrée sous Mac). On peut enfin sélectionner plusieurs lignes avec la souris ou le clavier et cliquer sur Run (ou utiliser le raccourci clavier), et l’ensemble des lignes est exécuté d’un coup. Au final, un script pourra ressembler à quelque chose comme ça : tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) mean(tailles) mean(poids) imc &lt;- poids / (tailles / 100) ^ 2 min(imc) max(imc) 2.4.1 Commentaires Les commentaires sont un élément très important d’un script. Il s’agit de texte libre, ignoré par R, et qui permet de décrire les étapes du script, sa logique, les raisons pour lesquelles on a procédé de telle ou telle manière… Il est primordial de documenter ses scripts à l’aide de commentaires, car il est très facile de ne plus se retrouver dans un programme qu’on a produit soi-même, même après une courte interruption. Pour ajouter un commentaire, il suffit de le faire précéder d’un ou plusieurs symboles #. En effet, dès que R rencontre ce caractère, il ignore tout ce qui se trouve derrière, jussqu’à la fin de la ligne. On peut donc documenter le script précédent : ## Saisie des tailles et poids des enquêtés tailles &lt;- c(156, 164, 197, 147, 173) poids &lt;- c(45, 59, 110, 44, 88) ## Calcul des tailles et poids moyens mean(tailles) mean(poids) ## Calcul de l&#39;IMC (poids en kilo divisé par les tailles en mètre au carré) imc &lt;- poids / (tailles / 100) ^ 2 ## Valeurs extrêmes de l&#39;IMC min(imc) max(imc) 2.5 Installer et charger des extensions (packages) R étant un logiciel libre, il bénéficie d’un développement communautaire riche et dynamique. L’installation de base de R permet de faire énormément de choses, mais le langage dispose en plus d’un système d’extensions permettant d’ajouter facilement de nouvelles fonctionnalités. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs de R, et diffusées via un réseau de serveurs nommé CRAN (Comprehensive R Archive Network). Pour installer une extension, et si on dispose d’une connexion Internet, on peut utiliser le bouton Install de l’onglet Packages de RStudio. Installer une extension Il suffit alors d’indiquer le nom de l’extension dans le champ Package et de cliquer sur Install. Installation d’une extension On peut aussi installer des extensions en utilisant la fonction install.packages() directement dans la console. Par exemple, pour installer le package questionr on peut exécuter la commande : install.packages(&quot;questionr&quot;) Installer une extension via l’une des deux méthodes précédentes va télécharger l’ensemble des fichiers nécessaires depuis l’une des machines du CRAN, puis installer tout ça sur le disque dur de votre ordinateur. Vous n’avez besoin de le faire qu’une fois, comme vous le faites pour installer un programme sur votre Mac ou PC. Une fois l’extension installée, il faut la “charger” avant de pouvoir utiliser les fonctions qu’elle propose. Ceci se fait avec la fonction library. Par exemple, pour pouvoir utiliser les fonctions de questionr, vous devrez exécuter la commande suivante : library(questionr) Ainsi, bien souvent, on regroupe en début de script toute une série d’appels à library qui permettent de charger tous les packages utilisés dans le script. Quelque chose comme : library(readxl) library(ggplot2) library(questionr) Si vous essayez d’exécuter une fonction d’une extension et que vous obtenez le message d’erreur impossible de trouver la fonction, c’est certainement parce que vous n’avez pas exécuté la commande library correspondante. 2.6 Exercices Exercice 1 Construire le vecteur suivant : [1] 120 134 256 12 Stocker ce vecteur dans un objet x et utilisez x pour générer les deux vecteurs suivants : [1] 220 234 356 112 [1] 240 268 512 24 Exercice 2 On a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage : conjoint1 &lt;- c(1200, 1180, 1750, 2100) conjoint2 &lt;- c(1450, 1870, 1690, 0) nb_personnes &lt;- c(4, 2, 3, 2) Calculer le revenu total par personne de chaque ménage. Exercice 3 Dans l’exercice précédent, calculer le revenu minimum et maximum parmi ceux du premier conjoint. conjoint1 &lt;- c(1200, 1180, 1750, 2100) Recommencer avec les revenus suivants, parmi lesquels l’un des enquetés n’a pas voulu répondre : conjoint1 &lt;- c(1200, 1180, 1750, NA) On peut ignorer pour le moment la présence du [1] en début de ligne.↩ c est l’abbréviation de combine, son nom est très court car on l’utilise très souvent↩ "],
["03-premier_travail.html", "Partie 3 Premier travail avec des données 3.1 Jeu de données d’exemple 3.2 Tableau de données (data frame) 3.3 Analyse univariée 3.4 Exercices", " Partie 3 Premier travail avec des données 3.1 Jeu de données d’exemple Dans cette partie nous allons (enfin) travailler sur des “vraies” données, et utiliser un jeu de données présent dans l’extension questionr. Nous devons donc avant toute chose installer cette extension. Pour installer ce package, deux possibilités : Dans l’onglet Packages de la zone de l’écran en bas à droite, cliquez sur le bouton Install. Dans le dialogue qui s’ouvre, entrez “questionr” dans le champ Packages puis cliquez sur Install. Saisissez directement la commande suivante dans la console : install.packages(&quot;questionr&quot;) Dans les deux cas, tout un tas de messages devraient s’afficher dans la console. Attendez que l’invite de commandes &gt; apparaisse à nouveau. Pour plus d’informations sur les extensions et leur installation, voir la section 2.5. Le jeu de données que nous allons utiliser est un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables. Pour une description plus complète et une liste des variables, voir la section A.3.2.2. Pour pouvoir utiliser ces données, il faut d’abord charger l’extension questionr (après l’avoir installée, bien entendu) : library(questionr) L’utilisation de library permet de rendre “disponibles”, dans notre session R, les fonctions et jeux de données inclus dans l’extension. Nous devons ensuite indiquer à R que nous souhaitons accéder au jeu de données à l’aide de la commande data : data(hdv2003) Cette commande ne renvoit aucun résultat particulier (sauf en cas d’erreur), mais vous devriez voir apparaître dans l’onglet Environment de RStudio un nouvel objet nommé hdv2003 : Onglet Environment Cet objet est d’un type nouveau : il s’agit d’un tableau de données. 3.2 Tableau de données (data frame) Un data frame (ou tableau de données, ou table) est un type d’objet dans R qui contient des données au format tabulaire, avec les observations en ligne et les variables en colonnes, comme dans une feuille de tableur de type LibreOffice ou Excel. Si on se contente d’exécuter le nom de notre tableau de données : hdv2003 R va, comme à son habitude, nous l’afficher dans la console, ce qui est tout sauf utile. Une autre manière d’afficher le contenu du tableau est de cliquer sur l’icône en forme de tableau à droite du nom de l’objet dans l’onglet Environment : View icon Ou d’utiliser la fonction View : View(hdv2003) Dans les deux cas votre tableau devrait s’afficher dans RStudio avec une interface de type tableur : Interface “View” Il est important de comprendre que l’objet hdv2003 contient l’intégralité des données du tableau. On voit donc qu’un objet peut contenir des données de types très différents (simple nombre, texte, vecteur, tableau de données entier), et être potentiellement de très grande taille5. Sous R, on peut importer ou créer autant de tableaux de données qu’on le souhaite, dans les limites des capacités de sa machine. Un data frame peut être manipulé comme les autres objets vus précédemment. On peut par exemple faire : d &lt;- hdv2003 ce qui va entraîner la copie de l’ensemble de nos données dans un nouvel objet nommé d. Ceci peut paraître parfaitement inutile mais a en fait l’avantage de fournir un objet avec un nom beaucoup plus court, ce qui diminuera la quantité de texte à saisir par la suite. Pour résumer, comme nous avons désormais décidé de saisir nos commandes dans un script et non plus directement dans la console, les premières lignes de notre fichier de travail sur les données de l’enquête Histoire de vie pourraient donc ressembler à ceci : ## Chargement des extensions nécessaires library(questionr) ## Jeu de données hdv2003 data(hdv2003) d &lt;- hdv2003 3.2.1 Structure du tableau Un tableau étant un objet comme un autre, on peut lui appliquer des fonctions. Par exemple, nrow et ncol retournent le nombre de lignes et de colonnes du tableau : nrow(d) [1] 2000 ncol(d) [1] 20 La fonction dim renvoit ses dimensions, donc les deux nombres précédents : dim(d) [1] 2000 20 La fonction names retourne les noms des colonnes du tableau, c’est-à-dire la liste de nos variables : names(d) [1] &quot;id&quot; &quot;age&quot; &quot;sexe&quot; &quot;nivetud&quot; [5] &quot;poids&quot; &quot;occup&quot; &quot;qualif&quot; &quot;freres.soeurs&quot; [9] &quot;clso&quot; &quot;relig&quot; &quot;trav.imp&quot; &quot;trav.satisf&quot; [13] &quot;hard.rock&quot; &quot;lecture.bd&quot; &quot;peche.chasse&quot; &quot;cuisine&quot; [17] &quot;bricol&quot; &quot;cinema&quot; &quot;sport&quot; &quot;heures.tv&quot; Enfin, la fonction str renvoit un descriptif plus détaillé de la structure du tableau. Elle liste les différentes variables, indique leur type6 et liste les premières valeurs : str(d) &#39;data.frame&#39;: 2000 obs. of 20 variables: $ id : int 1 2 3 4 5 6 7 8 9 10 ... $ age : int 28 23 59 34 71 35 60 47 20 28 ... $ sexe : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 2 2 1 1 2 2 2 1 2 1 ... $ nivetud : Factor w/ 8 levels &quot;N&#39;a jamais fait d&#39;etudes&quot;,..: 8 NA 3 8 3 6 3 6 NA 7 ... $ poids : num 2634 9738 3994 5732 4329 ... $ occup : Factor w/ 7 levels &quot;Exerce une profession&quot;,..: 1 3 1 1 4 1 6 1 3 1 ... $ qualif : Factor w/ 7 levels &quot;Ouvrier specialise&quot;,..: 6 NA 3 3 6 6 2 2 NA 7 ... $ freres.soeurs: int 8 2 2 1 0 5 1 5 4 2 ... $ clso : Factor w/ 3 levels &quot;Oui&quot;,&quot;Non&quot;,&quot;Ne sait pas&quot;: 1 1 2 2 1 2 1 2 1 2 ... $ relig : Factor w/ 6 levels &quot;Pratiquant regulier&quot;,..: 4 4 4 3 1 4 3 4 3 2 ... $ trav.imp : Factor w/ 4 levels &quot;Le plus important&quot;,..: 4 NA 2 3 NA 1 NA 4 NA 3 ... $ trav.satisf : Factor w/ 3 levels &quot;Satisfaction&quot;,..: 2 NA 3 1 NA 3 NA 2 NA 1 ... $ hard.rock : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... $ lecture.bd : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ... $ peche.chasse : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 2 2 1 1 ... $ cuisine : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 2 1 1 2 1 1 2 2 1 1 ... $ bricol : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 2 1 1 1 2 1 1 ... $ cinema : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 1 2 1 2 1 1 2 2 ... $ sport : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 2 2 1 2 1 1 1 2 ... $ heures.tv : num 0 1 0 2 3 2 2.9 1 2 2 ... Sous RStudio, on peut afficher à tout moment la structure d’un objet en cliquant sur l’icône de triangle sur fond bleu à gauche du nom de l’objet dans l’onglet Environment : Structure d’un objet 3.2.2 Accéder aux variables d’un tableau Une opération très importante est l’accès aux variables du tableau (à ses colonnes) pour pouvoir les manipuler, effectuer des calculs, etc. On va pour cela utiliser l’opérateur $, qui permet d’accéder aux colonnes du tableau. Ainsi, si l’on tape : d$sexe [1] Femme Femme Homme Homme Femme Femme Femme Homme Femme Homme Femme [12] Homme Femme Femme Femme Femme Homme Femme Homme Femme Femme Homme [23] Femme Femme Femme Homme Femme Homme Homme Homme Homme Homme Homme [34] Homme Femme Femme Homme Femme Femme Homme Femme Homme Homme Femme [45] Femme Homme Femme Femme Femme Femme Homme Femme Homme Femme Homme [56] Femme Femme Femme Homme Femme Femme Homme Homme Homme Homme Femme [67] Homme Homme Femme Femme Homme Homme Femme Femme Femme Femme Homme [78] Femme Femme Femme Femme Femme Femme Homme Homme Femme Homme Homme [89] Homme Homme Homme Femme Homme Femme Femme Femme Homme Homme Femme [100] Femme Femme Homme Femme Homme Homme Femme Femme Femme Femme Homme [111] Homme Homme Homme Homme Femme Homme Homme Femme Homme Homme Femme [122] Femme Femme Homme Femme Femme Homme Femme Femme Homme Femme Homme [133] Femme Femme Femme Homme Homme Homme Homme Homme Homme Homme Homme [144] Femme Homme Homme Homme Femme Femme Femme Homme Femme Femme Femme [155] Femme Homme Femme Homme Homme Homme Femme Homme Femme Homme Femme [166] Homme Homme Femme Femme Femme Homme Femme Homme Femme Femme Femme [177] Homme Homme Homme Femme Homme Femme Femme Homme Homme Femme Femme [188] Femme Femme Femme Homme Homme Femme Homme Homme Femme Homme Femme [199] Homme Femme [ reached getOption(&quot;max.print&quot;) -- omitted 1800 entries ] Levels: Homme Femme R va nous afficher l’ensemble des valeurs de notre variables sexe dans la console, ce qui est à nouveau fort peu utile. Mais cela nous permet de constater que d$sexe est un vecteur de chaînes de caractères tels qu’on en a déjà rencontré précédemment. La fonction table$colonne renvoit donc la colonne nommée colonne du tableau table, c’est-à-dire un vecteur, en général de nombres ou de chaînes de caractères. Si on souhaite afficher seulement les premières ou dernières valeurs d’une variable, on peut utiliser les fonctions head et tail : head(d$age) [1] 28 23 59 34 71 35 tail(d$age, 10) [1] 52 42 50 41 46 45 46 24 24 66 Le deuxième argument numérique permet d’indiquer le nombre de valeurs à afficher. 3.2.3 Créer une nouvelle variable On peut aussi utiliser l’opérateur $ pour créer une nouvelle variable dans notre tableau : pour cela, il suffit de lui assigner une valeur. Par exemple, la variable heures.tv contient le nombre d’heures passées quotidiennement devant la télé : head(d$heures.tv, 10) [1] 0.0 1.0 0.0 2.0 3.0 2.0 2.9 1.0 2.0 2.0 On peut vouloir créer une nouvelle variable dans notre tableau qui contienne la même durée mais en minutes. On va donc créer une nouvelle variables minutes.tv de la manière suivante : d$minutes.tv &lt;- d$heures.tv * 60 On peut alors constater, soit visuellement soit dans la console, qu’une nouvelle variable (une nouvelle colonne) a bien été ajoutée au tableau : head(d$minutes.tv) [1] 0 60 0 120 180 120 3.3 Analyse univariée On a donc désormais accès à un tableau de données d, dont les lignes sont des observations (des individus enquêtés), et les colonnes des variables (des caractéristiques de chacun de ces individus), et on sait accéder à ces variables grâce à l’opérateur $. Si on souhaite analyser ces variables, les méthodes et fonctions utilisées seront différentes selon qu’il s’agit d’une variable quantitative (variable numérique pouvant prendre un grand nombre de valeurs comme l’âge, le revenu, un pourcentage…) ou d’une variable qualitative (variable pouvant prendre un nombre limité de valeurs appelées modalités comme le sexe, la profession, etc.). 3.3.1 Analyser une variable quantitative Une variable quantitative est une variable de type numérique (un nombre) qui peut prendre un grand nombre de valeurs. On en a plusieurs dans notre jeu de données, notamment l’âge (variable age) ou le nombre d’heures passées devant la télé (heures.tv). 3.3.1.1 Indicateurs de centralité Caractériser une variable quantitative, c’est essayer de décrire la manière dont ses valeurs se répartissent, ou se distribuent. Pour cela on peut commencer par regarder les valeurs extrêmes, avec les fonctions min, max ou range : min(d$age) [1] 18 max(d$age) [1] 97 range(d$age) [1] 18 97 On peut aussi calculer des indicateurs de centralité : ceux-ci indiquent autour de quel nombre se répartissent les valeurs de la variable. Il y en a plusieurs, le plus connu étant la moyenne, qu’on peut calculer avec la fonction mean : mean(d$age) [1] 48.157 Il existe aussi la médiane, qui est la valeur qui sépare notre population en deux : on a la moitié de nos observations en-dessous, et la moitié au-dessus. Elle se calcule avec la fonction median : median(d$age) [1] 48 Une différence entre les deux indicateurs est que la médiane est beaucoup moins sensible aux valeurs “extrêmes” : on dit qu’elle est plus robuste. Ainsi, en 2013, le salaire net moyen des salariés à temps plein en France était de 2202 euros, tandis que le salaire net médian n’était que de 1772 euros. La différence étant due à des très hauts salaires qui “tirent” la moyenne vers le haut. 3.3.1.2 Indicateurs de dispersion Les indicateurs de dispersion permettent de mesurer si les valeurs sont plutôt regroupées ou au contraire plutôt dispersées. L’indicateur le plus simple est l’étendue de la distribution, qui décrit l’écart maximal observé entre les observations : max(d$age) - min(d$age) [1] 79 Les indicateurs de dispersion les plus utilisés sont la variance ou, de manière équivalente, l’écart-type (qui est égal à la racine carrée de la variance). On obtient la première avec la fonction var, et le second avec sd (abbréviation de standard deviation) : var(d$age) [1] 287.0249 sd(d$age) [1] 16.94181 Plus la variance ou l’écart-type sont élevés, plus les valeurs sont dispersées autour de la moyenne. À l’inverse, plus ils sont faibles et plus les valeurs sont regroupées. Une autre manière de mesurer la dispersion est de calculer les quartiles : le premier quartile est la valeur pour laquelle on a 25% des observations en dessous et 75% au dessus le deuxième quartile est la valeur pour laquelle on a 50% des observations en dessous et 50% au dessus (c’est donc la médiane) le troisième quartile est la valeur pour laquelle on a 75% des observations en dessous et 25% au dessus On peut les calculer avec la fonction quantile : ## Premier quartile quantile(d$age, prob = 0.25) 25% 35 ## Troisième quartile quantile(d$age, prob = 0.75) 75% 60 quantile prend deux arguments principaux : le vecteur dont on veut calculer le quantile, et un argument prob qui indique quel quantile on souhaite obtenir. prob prend une valeur entre 0 et 1 : 0.5 est la médiane, 0.25 le premier quartile, 0.1 le premier décile, etc. Notons enfin que la fonction summary permet d’obtenir d’un coup plusieurs indicateurs classiques : summary(d$age) Min. 1st Qu. Median Mean 3rd Qu. Max. 18.00 35.00 48.00 48.16 60.00 97.00 3.3.1.3 Représentation graphique L’outil le plus utile pour étudier la distribution des valeurs d’une variable quantitative reste la représentation graphique. La représentation la plus courante est sans doute l’histogramme. On peut l’obtenir avec la fonction hist : hist(d$age) Cette fonction n’a pas pour effet direct d’effectuer un calcul ou de nous renvoyer un résultat : elle génère un graphique qui va s’afficher dans l’onglet Plots de RStudio. On peut personnaliser l’apparence de l’histogramme en ajoutant des arguments supplémentaires à la fonction hist. L’argument le plus important est breaks, qui permet d’indiquer le nombre de classes que l’on souhaite. hist(d$age, breaks = 10) hist(d$age, breaks = 70) Le choix d’un “bon” nombre de classes pour un histogramme n’est pas un problème simple : si on a trop peu de classes, on risque d’effacer quasiment toutes les variations, et si on en a trop on risque d’avoir trop de détails et de masquer les grandes tendances. Les arguments de hist permettent également de modifier la présentation du graphique. On peut ainsi changer la couleur des barres avec col, le titre avec main, les étiquettes des axes avec xlab et ylab, etc. : hist(d$age, col = &quot;skyblue&quot;, main = &quot;Répartition des âges des enquêtés&quot;, xlab = &quot;Âge&quot;, ylab = &quot;Effectif&quot;) La fonction hist fait partie des fonctions graphique de base de R. La partie 8 de ce document est consacrée à l’extension ggplot2, qui fait partie du tidyverse et qui permet la production et la personnalisation de graphiques complexes sous R. 3.3.2 Analyser une variable qualitative Une variable qualitative est une variable qui ne peut prendre qu’un nombre limité de valeurs, appelées modalités. Dans notre jeu de données on trouvera par exemple le sexe (sexe), le niveau d’études (nivetud), la catégorie socio-professionnelle (qualif)… À noter qu’une variable qualitative peut tout-à-fait être numérique, et que certaines variables peuvent être traitées soit comme quantitatives, soit comme qualitatives : c’est le cas par exemple du nombre d’enfants ou du nombre de frères et soeurs. 3.3.2.1 Tri à plat L’outil le plus utilisé pour représenter la répartition des valeurs d’une variable qualitative est le tri à plat : il s’agit simplement de compter, pour chacune des valeurs possibles de la variable (pour chacune des modalités), le nombre d’observations ayant cette valeur. Un tri à plat s’obtient sous R à l’aide de la fonction table : table(d$sexe) Homme Femme 899 1101 Ce tableau nous indique donc que parmi nos enquêtés on trouve 899 hommes et 1101 femmes. table(d$qualif) Ouvrier specialise Ouvrier qualifie Technicien 203 292 86 Profession intermediaire Cadre Employe 160 260 594 Autre 58 Un tableau de ce type peut être affiché ou stocké dans un objet, et on peut à son tour lui appliquer des fonctions. Par exemple, la fonction sort permet de trier le tableau selon la valeur de l’effectif. On peut donc faire : tab &lt;- table(d$qualif) sort(tab) Autre Technicien Profession intermediaire 58 86 160 Ouvrier specialise Cadre Ouvrier qualifie 203 260 292 Employe 594 Attention, par défaut la fonction table n’affiche pas les valeurs manquantes (NA). Si on souhaite les inclure il faut utiliser l’argument useNA = “always”, soit : table(d$qualif, useNA = “always”). Par défaut ces tris à plat sont en effectifs et ne sont donc pas toujours très lisibles, notamment quand on a des effectifs importants. On leur rajoute donc en général la répartition en pourcentages. Pour cela, nous allons utiliser la fonction freq de l’extension questionr, qui devra donc avoir précédemment été chargée avec library(questionr) : ## À rajouter en haut de script et à exécuter library(questionr) On peut alors utiliser la fonction : freq(d$qualif) n % val% Ouvrier specialise 203 10.2 12.3 Ouvrier qualifie 292 14.6 17.7 Technicien 86 4.3 5.2 Profession intermediaire 160 8.0 9.7 Cadre 260 13.0 15.7 Employe 594 29.7 35.9 Autre 58 2.9 3.5 NA 347 17.3 NA La colonne n représente les effectifs de chaque catégorie, la colonne % le pourcentage, et la colonne val% le pourcentage calculé sur les valeurs valides, donc en excluant les NA. Une ligne a également été rajoutée pour indiquer le nombre et la proportion de NA. freq accepte un certain nombre d’arguments pour personnaliser son affichage. Par exemple : valid indique si on souhaite ou non afficher les pourcentages sur les valeurs valides cum indique si on souhaite ou non afficher les pourcentages cumulés total permet d’ajouter une ligne avec les effectifs totaux sort permet de trier le tableau par fréquence croissante (sort=&quot;inc&quot;) ou décroissante (sort=&quot;dec&quot;). freq(d$qualif, valid= FALSE, total = TRUE, sort = &quot;dec&quot;) n % Employe 594 29.7 NA 347 17.3 Ouvrier qualifie 292 14.6 Cadre 260 13.0 Ouvrier specialise 203 10.2 Profession intermediaire 160 8.0 Technicien 86 4.3 Autre 58 2.9 Total 2000 100.0 3.3.2.2 Représentations graphiques On peut représenter graphiquement le tri à plat d’une variable qualitative avec un diagramme en barres, obtenu avec la fonction barplot. Attention, contrairement à hist cette fonction ne s’applique pas directement à la variable mais au résultat du tri à plat de cette variable, calculé avec table. Il faut donc procéder en deux étapes : tab &lt;- table(d$clso) barplot(tab) On peut aussi trier le tri à plat avec la fonction sort avant de le représenter graphiquement, ce qui peut faciliter la lecture du graphique : barplot(sort(tab)) Une alternative au graphique en barres est le diagramme de Cleveland, qu’on peut obtenir avec la fonction dotchart. Celle-ci s’applique elle aussi au tri à plat de la variable calculé avec table. dotchart(table(d$qualif)) Là aussi, pour améliorer la lisibilité du graphique il est préférable de trier le tri à plat de la variable avant de le représenter : dotchart(sort(table(d$qualif))) 3.4 Exercices Exercice 1 Créer un nouveau script qui effectue les actions suivantes : charger l’extension questionr charger le jeu de données nommé hdv2003 copier le jeu de données dans un nouvel objet nommé df afficher les dimensions et la liste des variables de df Exercice 2 On souhaite étudier la répartition du temps passé devant la télévision par les enquêtés (variable heures.tv). Pour cela, affichez les principaux indicateurs de cette variable : valeur minimale, maximale, moyenne, médiane et écart-type. Représentez ensuite sa distribution par un histogramme en 10 classes. Exercice 3 On s’intéresse maintenant à l’importance accordée par les enquêtés à leur travail (variable trav.imp). Faites un tri à plat des effectifs des modalités de cette variable avec la commande table. Y’a-t-il des valeurs manquantes ? Faites un tri à plat affichant à la fois les effectifs et les pourcentages de chaque modalité. Représentez graphiquement les effectifs des modalités à l’aide d’un graphique en barres puis d’un diagramme de Cleveland. La seule limite pour la taille d’un objet étant la mémoire vive (RAM) de la machine sur laquelle tourne la session R.↩ Les types de variables seront décrits plus en détail dans le chapitre sur les recodages.↩ "],
["04-bivarie.html", "Partie 4 Analyse bivariée 4.1 Croisement de deux variables qualitatives 4.2 Croisement d’une variable quantitative et d’une variable qualitative 4.3 Croisement de deux variables quantitatives", " Partie 4 Analyse bivariée Faire une analyse bivariée, c’est étudier la relation entre deux variables : sont-elles liées ? les valeurs de l’une influencent-elles les valeurs de l’autre ? ou sont-elles au contraire indépendantes ? À noter qu’on va parler ici d’influence ou de lien, mais pas de relation de cause à effet : les outils présentés permettent de visualiser ou de déterminer une relation, mais des liens de causalité proprement dit sont plus difficiles à mettre en évidence. Il faut en effet vérifier que c’est bien telle variable qui influence telle autre et pas l’inverse, qu’il n’y a pas de “variable cachée”, etc. Là encore, le type d’analyse ou de visualisation est déterminé par la nature qualitative ou quantitative des deux variables. 4.1 Croisement de deux variables qualitatives 4.1.1 Tableaux croisés On va continuer à travailler avec le jeu de données tiré de l’enquête Histoire de vie inclus dans l’extension questionr. On commence donc par charger l’extension, le jeu de données, et à le renommer en un nom plus court pour gagner un peu de temps de saisie au clavier : library(questionr) data(hdv2003) d &lt;- hdv2003 Quand on veut croiser deux variables qualitatives, on fait un tableau croisé. Comme pour un tri à plat ceci s’obtient avec la fonction table de R, mais à laquelle on passe cette fois deux variables en argument. Par exemple, si on veut croiser la catégorie socio professionnelle et le sexe des enquêtés : table(d$qualif, d$sexe) Homme Femme Ouvrier specialise 96 107 Ouvrier qualifie 229 63 Technicien 66 20 Profession intermediaire 88 72 Cadre 145 115 Employe 96 498 Autre 21 37 Pour pouvoir interpréter ce tableau on doit passer du tableau en effectifs au tableau en pourcentages ligne ou colonne. Pour cela, on peut utiliser les fonctions lprop et cprop de l’extension questionr, qu’on applique au tableau croisé précédent. Pour calculer les pourcentages ligne : tab &lt;- table(d$qualif, d$sexe) lprop(tab) Homme Femme Total Ouvrier specialise 47.3 52.7 100.0 Ouvrier qualifie 78.4 21.6 100.0 Technicien 76.7 23.3 100.0 Profession intermediaire 55.0 45.0 100.0 Cadre 55.8 44.2 100.0 Employe 16.2 83.8 100.0 Autre 36.2 63.8 100.0 Ensemble 44.8 55.2 100.0 Et pour les pourcentages colonne : cprop(tab) Homme Femme Ensemble Ouvrier specialise 13.0 11.7 12.3 Ouvrier qualifie 30.9 6.9 17.7 Technicien 8.9 2.2 5.2 Profession intermediaire 11.9 7.9 9.7 Cadre 19.6 12.6 15.7 Employe 13.0 54.6 35.9 Autre 2.8 4.1 3.5 Total 100.0 100.0 100.0 Pour savoir si on doit faire des pourcentages ligne ou colonne, on pourra se référer à l’article suivant : http://alain-leger.lescigales.org/textes/lignecolonne.pdf En résumé, quand on fait un tableau croisé, celui-ci est parfaitement symétrique : on peut inverser les lignes et les colonnes, ça ne change pas son interprétation. Par contre, on a toujours en tête un “sens” de lecture dans le sens où on considère que l’une des variables dépend de l’autre. Par exemple, si on croise sexe et type de profession, on dira que le type de profession dépend du sexe, et non l’inverse : le type de profession est alors la variable dépendante (à expliquer), et le sexe la variable indépendante (explicative). Pour faciliter la lecture d’un tableau croisé, il est recommandé de faire les pourcentages sur la variable indépendante. Dans notre exemple, la variable indépendante est le sexe, elle est en colonne, on calcule donc les pourcentages colonnes qui permettent de comparer directement, pour chaque sexe, la répartition des catégories socio-professionnelles. 4.1.2 Test du χ² Comme on travaille sur un échantillon et pas sur une population entière, on peut compléter ce tableau croisé par un test d’indépendance du χ². Celui-ci permet de rejeter l’hypothèse d’indépendance des lignes et des colonnes du tableau, c’est à dire de rejeter l’hypothèse que les écarts à l’indépendance observés seraient uniquement dus au biais d’échantillonnage (au fait qu’on n’a pas interrogé toute notre population). Pour effectuer un test de ce type, on applique la fonction chisq.test au tableau croisé calculé précédemment : chisq.test(tab) Pearson&#39;s Chi-squared test data: tab X-squared = 387.56, df = 6, p-value &lt; 2.2e-16 Le résultat nous indique trois valeurs : X-squared, la valeur de la statistique du χ² pour notre tableau, c’est-à-dire une “distance” entre notre tableau observé et celui attendu si les deux variables étaient indépendantes. df, le nombre de degrés de libertés du test. p-value, le fameux p, qui indique la probabilité d’obtenir une valeur de la statistique du χ² au moins aussi extrême sous l’hypothèse d’indépendance. Ici, le p est extrêmement petit (la notation &lt; 2.2e-16 indique qu’il est plus petit que la plus petite valeur calculable par R), donc certainement en-dessous du seuil de décision choisi préalablement au test (souvent 5%, soit 0.05). On peut donc rejeter l’hypothèse d’indépendance des lignes et des colonnes du tableau. 4.1.3 Représentation graphique Il est possible de faire une représentation graphique d’un tableau croisé, par exemple avec la fonction mosaicplot : mosaicplot(tab) On peut améliorer ce graphique en colorant les cases selon les résidus du test du χ² (argument shade = TRUE) et en orientant verticalement les labels de colonnes (argument las = 3) : mosaicplot(tab, las = 3, shade = TRUE) Chaque rectangle de ce graphique représente une case de tableau. Sa largeur correspond au pourcentage des modalités en colonnes (il y’a beaucoup d’employés et d’ouvriers et très peu d’“autres”). Sa hauteur correspond aux pourcentages colonnes : la proportion d’hommes chez les cadres est plus élevée que chez les employés. Enfin, la couleur de la case correspond au résidu du test du χ² correspondant : les cases en rouge sont sous-représentées, les cases en bleu sur-représentées, et les cases blanches sont proches des effectifs attendus sous l’hypothèse d’indépendance. 4.2 Croisement d’une variable quantitative et d’une variable qualitative 4.2.1 Représentation graphique Croiser une variable quantitative et une variable qualitative, c’est essayer de voir si les valeurs de la variable quantitative se répartissent différemment selon la catégorie d’appartenance de la variable qualitative. Pour cela, l’idéal est de commencer par une représentation graphique de type “boîte à moustache” à l’aide de la fonction boxplot. Par exemple, si on veut visualiser la répartition des âges selon la pratique ou non d’un sport, on va utiliser la syntaxe suivante (le ~ peut se lire comme “en fonction de”) : boxplot(d$age ~ d$sport) L’interprétation d’un boxplot est la suivante : Les bords inférieurs et supérieurs du carré central représentent le premier et le troisième quartile de la variable représentée sur l’axe vertical. On a donc 50% de nos observations dans cet intervalle. Le trait horizontal dans le carré représente la médiane. Enfin, des “moustaches” s’étendent de chaque côté du carré, jusqu’aux valeurs minimales et maximales, avec une exception : si des valeurs sont éloignées du carré de plus de 1,5 fois l’écart interquartile (la hauteur du carré), alors on les représente sous forme de points (symbolisant des valeurs considérées comme “extrêmes”). Dans le graphique ci-dessus, on voit que ceux qui ont pratiqué un sport au cours des douze derniers mois ont l’air d’être sensiblement plus jeunes que les autres. 4.2.2 Calculs d’indicateurs On peut aussi vouloir comparer certains indicateurs (moyenne, médiane) d’une variable quantitative selon les modalités d’une variable qualitative. Si on reprend l’exemple précédent, on peut calculer la moyenne d’âge pour ceux qui pratiquent un sport et pour ceux qui n’en pratiquent pas. Une première méthode pour cela est d’extraire de notre population autant de sous-populations qu’il y a de modalités dans la variable qualitative. On peut le faire notamment avec la fonction filter du package dplyr.7 On commence par charger dplyr (en l’ayant préalablement installé) : library(dplyr) Puis on applique filter pour créer deux sous-populations, stockées dans deux nouveaux tableaux de données : d_sport &lt;- filter(d, sport == &quot;Oui&quot;) d_nonsport &lt;- filter(d, sport == &quot;Non&quot;) On peut ensuite utiliser ces deux nouveaux tableaux de données comme on en a l’habitude, et calculer les deux moyennes d’âge : mean(d_sport$age) [1] 40.92531 mean(d_nonsport$age) [1] 52.25137 Une autre possibilité est d’utiliser la fonction tapply, qui prend en paramètre une variable quantitative, une variable qualitative et une fonction, puis applique automatiquement la fonction aux valeurs de la variables quantitative pour chaque niveau de la variable qualitative : tapply(d$age, d$sport, mean) Non Oui 52.25137 40.92531 On verra dans la partie 9 d’autres méthodes basées sur dplyr pour effectuer ce genre d’opérations. 4.2.3 Tests statistiques Un des tests les plus connus est le test du t de Student, qui permet de tester si les moyennes de deux sous-populations peuvent être considérées comme différentes (compte tenu des fluctuations aléatoires provenant du biais d’échantillonnage). Un test t s’effectue à l’aide de la fonction t.test. Ainsi, on peut tester l’hypothèse d’égalité des âges moyens selon la pratique ou non d’un sport avec la commande suivante : t.test(d$age ~ d$sport) Welch Two Sample t-test data: d$age by d$sport t = 15.503, df = 1600.4, p-value &lt; 2.2e-16 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 9.893117 12.759002 sample estimates: mean in group Non mean in group Oui 52.25137 40.92531 Le résultat du test est significatif, avec un p extrêmement petit, et on peut rejeter l’hypothèse nulle d’égalité des moyennes des deux groupes. Le test nous donne même un intervalle de confiance à 95% pour la valeur de la différence entre les deux moyennes. Nous sommes cependant allés un peu vite, et avons négligé le fait que le test t s’applique normalement à des distributions normales. On peut se faire un premier aperçu visuel de cette normalité en traçant les histogrammes des deux répartitions : hist(d_sport$age) hist(d_nonsport$age) Si l’âge dans le groupe des non sportifs se rapproche d’une distribution normale, celui des sportifs en semble assez éloigné, notamment du fait de la limite d’âge à 18 ans imposée par construction de l’enquête. On peut tester cette normalité à l’aide du test de Shapiro-Wilk et de la fonction shapiro.test : shapiro.test(d_sport$age) Shapiro-Wilk normality test data: d_sport$age W = 0.96203, p-value = 9.734e-13 shapiro.test(d_nonsport$age) Shapiro-Wilk normality test data: d_nonsport$age W = 0.98844, p-value = 1.654e-08 Le test est significatif dans les deux cas et rejette l’hypothèse d’une normalité des deux distributions. Dans ce cas on peut faire appel à un test non-paramétrique, qui ne fait donc pas d’hypothèses sur les lois de distribution des variables testées, en l’occurrence le test des rangs de Wilcoxon, à l’aide de la fonction wilcox.test : wilcox.test(d$age ~ d$sport) Wilcoxon rank sum test with continuity correction data: d$age by d$sport W = 640580, p-value &lt; 2.2e-16 alternative hypothesis: true location shift is not equal to 0 La valeur p étant à nouveau extrêmement petite, on peut rejeter l’hypothèse d’indépendance et considérer que les distributions des âges dans les deux sous-populations sont différentes. 4.3 Croisement de deux variables quantitatives Le jeu de données hdv2003 comportant assez peu de variables quantitatives, on va s’intéresser maintenant à un autre jeu de données comportant des informations du recensement de la population de 2012. On le charge avec : data(rp2012) Un nouveau tableau de données rp2012 devrait apparaître dans votre environnement. Celui-ci comprend les 5170 communes de Métropole de plus de 2000 habitants, et une soixantaine de variables telles que le département, la population, le taux de chômage, etc. Pour une description plus complète et une liste des variables, voir section A.3.2.3. 4.3.1 Représentation graphique Quand on croise deux variables quantitatives, l’idéal est de faire une représentation graphique sous forme de nuage de points à l’aide de la fonction plot. On va représenter le croisement entre le pourcentage de cadres et le pourcentage de diplômés du supérieur dans la commune : plot(rp2012$cadres, rp2012$proprio) Une représentation graphique est l’idéal pour visualiser l’existence d’un lien entre les deux variables. Voici quelques exemples d’interprétation : Dans ce premier graphique généré sur nos données, il semble difficile de mettre en évidence une relation de dépendance. Si par contre on croise le pourcentage de cadres et celui de diplômés du supérieur, on obtient une belle relation de dépendance linéaire. plot(rp2012$cadres, rp2012$dipl_sup) 4.3.2 Calcul d’indicateurs En plus d’une représentation graphique, on peut calculer certains indicateurs permettant de mesurer le degré d’association de deux variables quantitatives. 4.3.2.1 Corrélation linéaire (Pearson) La corrélation est une mesure du lien d’association linéaire entre deux variables quantitatives. Sa valeur varie entre -1 et 1. Si la corrélation vaut -1, il s’agit d’une association linéaire négative parfaite. Si elle vaut 1, il s’agit d’une association linéaire positive parfaite. Si elle vaut 0, il n’y a aucune association linéaire entre les variables. On la calcule dans R à l’aide de la fonction cor. Ainsi la corrélation entre le pourcentage de cadres et celui de diplômés du supérieur vaut : cor(rp2012$cadres, rp2012$dipl_sup) [1] 0.9371629 Ce qui est extrêmement fort. Il y a donc un lien linéaire et positif entre les deux variables (quand la valeur de l’une augmente, la valeur de l’autre augmente également). À l’inverse, la corrélation entre le pourcentage de cadres et le pourcentage de propriétaires vaut : cor(rp2012$cadres, rp2012$proprio) [1] 0.1622786 Ce qui indique, pour nos données, une absence de liaison linéaire entre les deux variables. 4.3.2.2 Corrélation des rangs (Spearman) Le coefficient de corrélation de Pearson ci-dessus fait une hypothèse forte sur les données : elles doivent être liées par une association linéaire. Quand ça n’est pas le cas mais qu’on est en présence d’une association monotone, on peut utiliser un autre coefficient, le coefficient de corrélation des rangs de Spearman. Plutôt que de se baser sur les valeurs des variables, cette corrélation va se baser sur leurs rangs, c’est-à-dire sur leur position parmi les différentes valeurs prises par les variables. Ainsi, si la valeur la plus basse de la première variable est associée à la valeur la plus basse de la deuxième, et ainsi de suite jusqu’à la valeur la plus haute, on obtiendra une corrélation de 1. Si la valeur la plus forte de la première variable est associée à la valeur la plus faible de la seconde, et ainsi de suite, et que la valeur la plus faible de la première est associée à la plus forte de la deuxième, on obtiendra une corrélation de -1. Si les rangs sont “mélangés”, sans rapports entre eux, on obtiendra une corrélation autour de 0. La corrélation des rangs a aussi pour avantage d’être moins sensibles aux valeurs extrêmes ou aux points isolés. On dit qu’elle est plus “robuste”. Pour calculer une corrélation de Spearman, on utilise la fonction cor mais avec l’argument method = &quot;spearman&quot; : cor(rp2012$cadres, rp2012$dipl_sup, method = &quot;spearman&quot;) [1] 0.9036273 4.3.3 Régression linéaire Quand on est en présence d’une association linéaire entre deux variables, on peut vouloir faire la régression d’une des variables sur l’autres. Une régression linéaire simple se fait à l’aide de la fonction lm : lm(rp2012$cadres ~ rp2012$dipl_sup) Call: lm(formula = rp2012$cadres ~ rp2012$dipl_sup) Coefficients: (Intercept) rp2012$dipl_sup 0.9217 1.0816 Pour des résultats plus détaillés, on peut stocker le résultat de la régression dans un objet et utiliser la fonction summary : reg &lt;- lm(rp2012$cadres ~ rp2012$dipl_sup) summary(reg) Call: lm(formula = rp2012$cadres ~ rp2012$dipl_sup) Residuals: Min 1Q Median 3Q Max -33.218 -1.606 -0.172 1.491 13.001 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 0.921661 0.071814 12.83 &lt;2e-16 *** rp2012$dipl_sup 1.081636 0.005601 193.10 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 2.701 on 5168 degrees of freedom Multiple R-squared: 0.8783, Adjusted R-squared: 0.8783 F-statistic: 3.729e+04 on 1 and 5168 DF, p-value: &lt; 2.2e-16 Le résultat montre que les coefficients sont significativement différents de 0. La part de cadres augmente donc avec celle de diplômés du supérieur. On peut facilement représenter la droite de régression à l’aide de la fonction abline : plot(rp2012$dipl_sup, rp2012$cadres) abline(reg, col=&quot;red&quot;) Le package en question est présenté en détail dans la partie 9.↩ "],
["05-organiser.html", "Partie 5 Organiser ses scripts 5.1 Les projets dans RStudio 5.2 Créer des sections 5.3 Répartir son travail entre plusieurs scripts 5.4 Désactiver la sauvegarde et le chargement automatique de l’environnement par RStudio", " Partie 5 Organiser ses scripts On l’a vu, le script est l’élément central de toute analyse dans R. C’est lui qui contient l’ensemble des actions constitutifs d’une analyse, dans leur ordre d’exécution : chargement des données, recodages, manipulations, calculs et exports de résultats… Une conséquence est qu’un script peut rapidement devenir très long, et on peut finir par s’y perdre. Il est donc nécessaire d’organiser son travail pour pouvoir se retrouver facilement parmi les différentes étapes d’un projet d’analyse. 5.1 Les projets dans RStudio La notion de projet est une fonctionnalité très pratique de RStudio, qui permet d’organiser son travail et de faciliter l’accès à l’ensemble des fichiers constitutifs d’une analyse (données, scripts, documentation, etc.). En pratique, un projet est un dossier que vous avez créé où bon vous semble sur votre disque dur, et dans lequel vous regrouperez tous les fichiers en question. Utilisez des projets procure plusieurs avantages : RStudio lance automatiquement R dans le dossier du projet et facilite ainsi grandement l’accès aux fichiers de données à importer (plus besoin de taper le chemin d’accès complet). De même, si vous déplacez votre dossier sur votre disque, le projet continuera à fonctionner. L’onglet Files de la zone en bas à droite de l’interface de RStudio vous permet de naviguer facilement dans les fichiers de votre projet. Vous pouvez très facilement passer d’un projet à l’autre si vous travaillez sur plusieurs jeux de données en parallèle. Pour créer un projet, il faut aller dans le menu File puis sélectionner New project. Création d’un nouveau projet Selon que le dossier du projet existe déjà ou pas, on choisira Existing directory ou New directory. L’étape d’après consiste à créer ou sélectionner le dossier, puis on n’a plus qu’à cliquer sur Create project. À la création du projet, et chaque fois, que vous l’ouvrirez, une nouvelle session R est lancée dans la fenêtre Console avec le dossier du projet comme répertoire de travail, et l’onglet Files affiche les fichiers contenus dans ce dossier. Une fois le projet créé, son nom est affiché dans un petit menu déroulant en haut à droite de l’interface de RStudio (menu qui permet de passer facilement d’un projet à un autre). Menu projets Si vous ne retrouvez pas le nom du projet dans ce menu, vous pouvez l’ouvrir en sélectionnant File puis Open Project… et en allant sélectionner le fichier .Rproj qui se trouve dans le dossier du projet à ouvrir. 5.2 Créer des sections Lorsqu’un script est long, RStudio permet de créer des “sections” facilitant la navigation. Pour créer une section, il suffit de faire suivre une ligne de commentaires par plusieurs tirets -, comme ceci : ## Titre de la section ------------------------------------- Le nombre de tirets n’a pas d’importance, il doit juste y’en avoir plus de quatre. À partir de là, RStudio affiche dans la marge de gauche du script un petit triangle noir qui permet de replier ou déplier le contenu de la section : Section de script dépliée Section de script repliée De plus, en cliquant sur l’icône Show document outline (la plus à droite de la barre d’outils de la fenêtre du script), ou en utilisant le raccourci clavier Ctrl+Shift+O, RStudio affiche une “table des matières” automatiquement mise à jour qui liste les sections existantes et permet de naviguer facilement dans le script : Liste dynamique des sections 5.3 Répartir son travail entre plusieurs scripts Si le script devient très long, les sections peuvent ne plus être suffisantes. De plus, il est souvent intéressant d’isoler certaines parties d’un script, par exemple pour pouvoir la mutualiser. On peut alors répartir les étapes d’une analyse entre plusieurs scripts. Un exemple courant concerne les recodages et la manipulation des données. Il est fréquent, au cours d’une analyse, de calculer de nouvelles variables, recoder des variables qualitatives existantes, etc. Il peut alors être intéressant de regrouper tous ces recodages dans un script à part (nommé, par exemple, recodages.R). Ce contient alors l’ensemble des recodages “validés”, ceux qu’on a testé et qu’on sait vouloir conserver. Pour exécuter ces recodages, on peut évidemment ouvrir le script recodages.R dans RStudio et lancer l’ensemble du code qu’il contient. Mais il est beaucoup plus pratique d’utiliser la fonction source : celle-ci prend en paramètre un nom de fichier .R, et quand on l’exécute elle va exécuter l’ensemble du code contenu dans ce fichier. Ainsi, un début de script analyse.R pourra ressembler à ceci : ## Analyse des données Histoire de vie 2003 ## Chargement des extensions et des données -------------------------- library(tidyverse) library(questionr) data(hdv2003) source(&quot;recodages.R&quot;) ## Analyse de l&#39;âge -------------------------------------------------- hist(hdv2003$age) (...) L’avantage principal est qu’on peut à tout moment revenir à nos données d’origine et aux recodages “validés” simplement en exécutant les deux lignes : data(hdv2003) source(&quot;recodages.R&quot;) L’autre avantage est qu’on peut répartir nos analyses entre différents scripts, et conserver ces deux lignes en haut de chaque script, ce qui permet de “mutualiser” les recodages validés. On pourrait ainsi créer un deuxième script analyse_qualif.R qui pourrait ressembler à ceci : ## Analyse des données Histoire de vie 2003 - Qualifications ## Chargement des extensions et des données -------------------------- library(tidyverse) library(questionr) data(hdv2003) source(&quot;recodages.R&quot;) ## Analyse des qualifications -------------------------------------------------- freq(hdv2003$qualif) (...) On peut évidemment répartir les recodages entre plusieurs fichiers et faire appel à autant de source que l’on souhaite. Cette organisation recalcule l’ensemble des recodages à chaque début de script. C’est intéressant et pratique pour des données de taille raisonnable, mais pour des fichiers plus volumineux les calculs peuvent être trop longs. Dans ce cas il est préférable de créer des scripts dédiés qui chargent les données source, effectuent calculs et recodages, et enregistrent les données résultantes dans un fichier de données (voir la section 7 sur l’import/export de données). Et c’est ce fichier résultat qui sera chargé par les scripts d’analyse. Enfin, pour des projets un peu complexes, on pourra se référer à l’extension ProjectTemplate, qui propose une architecture de dossiers spécifique et des outils associés. 5.4 Désactiver la sauvegarde et le chargement automatique de l’environnement par RStudio Vous avez sans doute remarqué qu’au moment de quitter RStudio, une boîte de dialogue semble à ceci s’affiche parfois : Dialogue d’enregistrement de l’espace de travail Et il est bien difficile de comprendre de quoi cela parle. Il s’agit en fait d’une fonctionnalité de R lui-même qui propose d’enregistrer notre espace de travail (workspace), c’est-à-dire l’ensemble des objets qui existent actuellement dans notre environnement, dans un fichier nommé .RData. La prochaine fois que R est lancé dans le même dossier (par exemple à la réouverture du projet), s’il trouve un fichier .RData il va le lire automatiquement et restaurer l’ensemble des objets dans l’état où ils étaient. Ceci peut sembler pratique, mais c’est en fait une mauvaise idée, pour deux raisons : on peut se retrouver avec des objets dont on ne sait plus d’où ils viennent et comment ils ont été calculés cette manière de faire casse la logique principale de R, qui est que c’est le script qui est central, et que c’est lui qui retrace toutes les étapes de notre analyse et permet de les reproduire Il est donc fortement recommandé, juste après l’installation de RStudio, de désactiver cette fonctionnalité. Pour cela, aller dans le menu Tools, puis Global Options, et s’assurer que : la case Restore .RData into workspace at startup est décochée le champ Save workspace to .RData on exit vaut Never Options d’enregistrement de l’espace de travail "],
["06-tidyverse.html", "Partie 6 Le tidyverse 6.1 Extensions 6.2 Installation 6.3 tidy data 6.4 tibbles et data frames", " Partie 6 Le tidyverse 6.1 Extensions Le terme tidyverse est une contraction de tidy (qu’on pourrait traduire par “bien rangé”) et de universe. Il s’agit en fait d’une collection d’extensions conçues pour travailler ensemble et basées sur une philosophie commune. Elles abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive) : visualisation manipulation des tableaux de données import/export de données manipulation de variables extraction de données du Web programmation Un des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham, qui travaille désormais pour RStudio. 6.2 Installation tidyverse est également le nom d’une extension qu’on peut installer de manière classique, soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la comande : install.packages(&quot;tidyverse&quot;) Cette commande va en fait installer plusieurs extensions qui constituent le “coeur” du tidyverse, à savoir : ggplot2 (visualisation) dplyr (manipulation des données) tidyr (remise en forme des données) purrr (programmation) readr (importation de données) tibble (tableaux de données) De la même manière, charger l’extension avec : library(tidyverse) Chargera l’ensemble des extensions précédentes. Il existe d’autres extensions qui font partie du tidyverse mais qui doivent être installées et chargées à part, comme forcats (pour le recodage des variables qualitatives) ou readxl (pour l’importation de données depuis des fichiers Excel). La liste complète des extensions se trouve sur le site officiel du tidyverse. 6.3 tidy data Le tidyverse est en partie fondé sur le concept de tidy data, développé à l’origine par Hadley Wickham dans un article de 2014 du Journal of Statistical Software. Il s’agit d’un modèle d’organisation des données qui vise à faciliter le travail souvent long et fastidieux de nettoyage et de préparation des données préalable à la mise en oeuvre de méthodes d’analyse. Les principes d’un jeu de données tidy sont les suivants : chaque variable est une colonne chaque observation est une ligne chaque type d’observation est dans une table différente On verra plus précisément dans la section 11 comment définir et rendre des données tidy avec notamment l’extension tidyr. Les extensions du tidyverse, notamment ggplot2 et dplyr, sont prévues pour fonctionner avec des données tidy. 6.4 tibbles et data frames Une autre particularité du tidyverse est que ces extensions travaillent avec des tableaux de données au format tibble, qui est une évolution plus moderne du classique data frame du R de base. Ce format est fourni est géré par l’extension du même nom (tibble), qui fait partie du coeur du tidyverse. La plupart des fonctions des extensions du tidyverse accepetent des data frames en entrée, mais retournent un objet de classe tibble. Contrairement aux data frames, les tibbles : n’ont pas de rownames autorisent des noms de colonnes invalides pour les data frames (espaces, caractères spéciaux, nombres…)8 s’affichent plus intelligemment que les data frames : seules les premières lignes sont affichées, ainsi que quelques informations utiles ne font pas de partial matching sur les noms de colonnes9 affichent un avertissement si on essaie d’accéder à une colonne qui n’existe pas Pour autant, les tibbles restent compatibles avec les data frames. On peut facilement convertir un data frame en tibble avec as_tibble : as_tibble(mtcars) # A tibble: 32 x 11 mpg cyl disp hp drat wt qsec vs am gear carb * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 3 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 6 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 7 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 8 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 9 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 10 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 # ... with 22 more rows Si le data frame d’origine a des rownames, on peut d’abord les convertir en colonnes avec rownames_to_columns : d &lt;- mtcars d &lt;- rownames_to_column(d) d &lt;- as_tibble(d) d # A tibble: 32 x 12 rowname mpg cyl disp hp drat wt qsec vs am &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 2 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 3 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 5 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 6 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 7 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 8 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 9 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 10 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 # ... with 22 more rows, and 2 more variables: gear &lt;dbl&gt;, carb &lt;dbl&gt; À l’inverse, on peut à tout moment convertir un tibble en data frame avec as.data.frame : as.data.frame(d) # A tibble: 32 x 12 rowname mpg cyl disp hp drat wt qsec vs am &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 2 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 3 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 5 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 6 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 7 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 8 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 9 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 10 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 # ... with 22 more rows, and 2 more variables: gear &lt;dbl&gt;, carb &lt;dbl&gt; Là encore, on peut convertir la colonne rowname en “vrais” rownames avec column_to_rownames : column_to_rownames(as.data.frame(d)) # A tibble: 32 x 11 mpg cyl disp hp drat wt qsec vs am gear carb * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 3 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 6 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 7 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 8 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 9 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 10 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 # ... with 22 more rows Quand on veut utiliser des noms de ce type, on doit les entourer avec des backticks (```)↩ Dans R de base, si une table d contient une colonne qualif, d$qual retournera cette colonne.↩ "],
["07-import.html", "Partie 7 Importer et exporter des données 7.1 Import de fichiers textes 7.2 Import depuis un fichier Excel 7.3 Import de fichiers SAS, SPSS et Stata 7.4 Import de fichiers dBase 7.5 Connexion à des bases de données 7.6 Export de données", " Partie 7 Importer et exporter des données R n’est pas prévu pour la saisie de données, mais il bénéficie de nombreuses fonctions et packages permettant l’import de données depuis un grand nombre de formats. Seuls les plus courants seront abordés ici. Il est très vivement conseillé de travailler avec les projets de RStudio pour faciliter l’accès aux fichiers et pouvoir regrouper l’ensemble des éléments d’une analyse dans un dossier (voir partie [projets]). 7.1 Import de fichiers textes L’extension readr, qui fait partie du tidyverse, permet l’importation de fichiers texte, notamment au format CSV (Comma separated values). Si votre fichier CSV suit un format CSV standard (c’est le cas s’il a été exporté depuis LibreOffice par exemple), avec des champs séparés par des virgules, vous pouvez utiliser la fonction read_csv en lui passant en argument le nom du fichier : d &lt;- read_csv(&quot;fichier.csv&quot;) Si votre fichier vient d’Excel, avec des valeurs séparées par des points virgule, utilisez la fonction read_csv2 : d &lt;- read_csv2(&quot;fichier.csv&quot;) Dans les mêmes familles de fonction, read_tsv permet d’importer des fichiers dont les valeurs sont séparées par des tabulations, et read_delim des fichiers délimités par un séparateur indiqué en argument. Chaque fonction dispose de plusieurs arguments, parmi lesquels : col_names indique si la première ligne contient le nom des colonnes (TRUE par défaut) col_types permet de spécifier manuellement le type des colonnes si readr ne les identifie pas correctement na est un vecteur de chaînes de caractères indiquant les valeurs devant être considérées comme manquantes. Ce vecteur vaut c(&quot;&quot;, &quot;NA&quot;) par défaut Il peut arriver, notamment sous Windows, que l’encodage des caractères accentués ne soit pas correct au moment de l’importation. On peut spécifier manuellement l’encodage du fichier importé à l’aide de l’option locale. Par exemple, si l’on est sous Mac ou Linux et que le fichier a été créé sous Windows, il est possible qu’il soit encodé au format iso-8859-1. On peut alors l’importer avec : d &lt;- read_csv(&quot;fichier.csv&quot;, locale = locale(encoding = &quot;ISO-8859-1&quot;)) À l’inverse, si vous importez un fichier sous Windows et que les accents ne sont pas affichés correctement, il est sans doute encodé en UTF-8 : d &lt;- read_csv(&quot;fichier.csv&quot;, locale = locale(encoding = &quot;UTF-8&quot;)) Pour plus d’informations, voir le site de l’extension : http://readr.tidyverse.org/ À noter que si vous souhaitez importer des fichiers textes très volumineux le plus rapidement possible, la fonction fread de l’extension data.table est plus rapide que read_csv. 7.1.1 Interface interactive d’import de fichiers RStudio propose une interface permettant d’importer un fichier de données de manière interactive. Pour cela, dans l’onglet Environment, cliquer sur le bouton Import Dataset : Menu Import Dataset Sélectionner From Text (readr)…. Une fenêtre s’affiche : Dialogue d’importation Il vous suffit d’indiquer le fichier à importer dans le champ File/URL tout en haut (vous pouvez même indiquer un lien vers un fichier distant via HTTP). Un aperçu s’ouvre dans la partie Data Preview et vous permet de vérifier si l’import est correct : Exemple de dialogue d’importation Vous pouvez modifier les options d’importation, changer le type des colonnes, etc. et l’aperçu se met à jour. De même, le code correspondant à l’importation du fichier avec les options sélectionnées est affiché dans la partie Code Preview. Important : une fois que l’import semble correct, ne cliquez pas sur le bouton Import. À la place, sélectionnez le code généré et copiez-le (ou cliquez sur l’icône en forme de presse papier) et choisissez Cancel. Ensuite, collez le code dans votre script et exécutez-le (vous pouvez supprimer la ligne commençant par View). Cette manière de faire permet “d’automatiser” l’importation des données, puisqu’à la prochaine ouverture du script vous aurez juste à exécuter le code en question, et pas à repasser par l’interface d’import. 7.2 Import depuis un fichier Excel L’extension readxl, qui ait également partie du tidyverse, permet d’importer des données directement depuis un fichier au format xlsou xlsx. Pour cela on peut utiliser la fonction read_excel en lui spécifiant le nom du fichier : d &lt;- read_excel(&quot;fichier.xls&quot;) Il est possible de spécifier la feuille que l’on souhaite importer et la plage de cellules avec les arguments sheet et range : d &lt;- read_excel(&quot;fichier.xls&quot;, sheet = &quot;Feuille2&quot;, range = &quot;C1:F124&quot;) Comme pour l’import de fichiers texte, une interface interactive d’import est disponible dans RStudio dans l’onglet Environment. Cliquer sur Import Dataset puis From Excel…. Dialogue d’importation d’un fichier Excel Spécifiez le chemin ou l’URL du fichier dans le premier champ, vérifiez l’import dans la partie Data Preview, modifiez si besoin les options d’importation, copiez le code d’importation généré dans la partie Code Preview et collez le dans votre script. Pour plus d’informations, voir le site de l’extension : http://readxl.tidyverse.org/ 7.3 Import de fichiers SAS, SPSS et Stata L’import de fichiers de données au format SAS, SPSS ou Stata se fait via les fonctions de l’extension haven. Pour les fichiers provenant de SAS, vous pouvez utiliser les fonctions read_sas ou read_xpt Pour les fichiers provenant de SPSS, vous pouvez utiliser read_sav ou read_por Pour les fichiers provenant de Stata, utilisez read_dta Chaque fonction dispose de plusieurs options. Le plus simple est d’utiliser, là aussi l’interface interactive d’importation de données de RStudio : dans l’onglet Environment, sélectionnez Import Dataset puis From SPSS, From SAS ou From Stata. Indiquez le chemin ou l’url du fichier, réglez les options d’importation, puis copiez le code d’importation généré et collez le dans votre script. Pour plus d’informations, voir le site de l’extension : http://haven.tidyverse.org/ 7.4 Import de fichiers dBase Le format dBase est encore utilisé, notamment par l’INSEE, pour la diffusion de données volumineuses. Les fichiers au format dbf peuvent être importées à l’aide de la fonction read.dbf de l’extension foreign10 : library(foregin) d &lt;- read.dbf(&quot;fichier.dbf&quot;) La fonction read.dbf n’admet qu’un seul argument, as.is. Si as.is = FALSE (valeur par défaut), les chaînes de caractères sont automatiquement converties en factor à l’importation. Si as.is = TRUE, elles sont conservées telles quelles. 7.5 Connexion à des bases de données R est capable de s’interfacer avec différents systèmes de bases de données relationnelles, dont sqlite, MS SQL Server, PostgreSQL, MariaDB, etc. L’extension dplyr (voir section [dplyr]), via le package dbplyr, peut être utilisé pour interroger directement ces bases de données avec la syntaxe de dplyr et récupérer les résultats dans R sous forme de tableaux de données. Il est également possible d’interagir directement avec les bases de données en leur envoyant des requêtes SQL. À titre d’illustration, le code suivant permet de se connecter à une base de données SQLite et de l’interroger via dplyr : library(dplyr) con &lt;- DBI::dbConnect(RSQLite::SQLite(), path = &quot;bdd.sqlite&quot;) villes_db &lt;- tbl(con, &quot;villes&quot;) villes %&gt;% filter(population &gt; 10000) %&gt;% select(nom, departement, population) Pour plus d’informations, voir la documentation très complète (en anglais) sur : https://db.rstudio.com/ 7.6 Export de données 7.6.1 Export de tableaux de données On peut avoir besoin d’exporter un tableau de données dans R vers un fichier dans différents formats. La plupart des fonctions d’import disposent d’un équivalent permettant l’export de données. On citera notamment : write_csv, write_csv2, read_tsv permettent d’enregistrer un data frame dans un fichier au format texte délimité write_sas permet d’exporter au format SAS write_sav permet d’exporter au format SPSS write_dta permet d’exporter au format Stata Il n’existe par contre pas de fonctions permettant d’enregistrer directement au format xls ou xlsx. On peut dans ce cas passer par un fichier CSV. Ces fonctions sont utiles si on souhaite diffuser des données à quelqu’un d’autre, ou entre deux logiciels. Si vous travaillez sur des données de grandes dimensions, les formats texte peuvent être lents à exporter et importer. Dans ce cas, l’extension feather peut être utile : elle permet d’enregistrer un data frame au format feather, qui n’est pas le plus compact mais qui est extrêmement rapide à lire et écrire.11 Les fonctions read_feather et write_feather permettent d’importer et exporter des tableaux de données dans ce format. 7.6.2 Sauvegarder des objets Une autre manière de sauvegarder des données est de les enregistrer au format Rdata. Ce format est compact, rapide, et permet d’enregistrer plusieurs objets R, quel que soit leur type, dans un même fichier. Pour enregistrer des objets, il suffit d’utiliser la fonction save et de lui fournit la liste des objets à sauvegarder et le nom du fichier : save(d, rp2012, tab, file = &quot;fichier.Rdata&quot;) Pour charger des objets préalablement enregistrés, utiliser load : load(&quot;fichier.Rdata&quot;) Attention, quand on utilise load, les objets chargés sont importés directement dans l’environnement en cours avec leur nom d’origine. Si d’autres objets du même nom existaient déjà, ils sont écrasés sans avertissement. foreign est une extension installée de base avec R, vous n’avez pas besoin de l’installer, il vous suffit de la charger avec library↩ feather est un format compatible avec Python, R et Julia. Pour plus d’informations voir https://github.com/wesm/feather↩ "],
["08-ggplot2.html", "Partie 8 Représentations graphiques 8.1 Préparation 8.2 Initialisation 8.3 Exemples de geom 8.4 Représentation de plusieurs geom 8.5 Mappages (aesthetics) 8.6 facets 8.7 scales 8.8 Thèmes 8.9 Ressources 8.10 Exercices", " Partie 8 Représentations graphiques ggplot2 est une extension du tidyverse qui permet de générer des graphiques avec une syntaxe cohérente et puissante. Elle nécessite l’apprentissage d’un “mini-langage” supplémentaire, mais permet la construction de graphiques complexes de manière efficace. Une des particularités de ggplot2 est qu’elle part du principe que les données relatives à un graphique sont stockées dans un tableau de données (data frame, tibble ou autre). 8.1 Préparation ggplot2 fait partie du tidyverse, elle est donc chargée automatiquement avec : library(tidyverse) On peut également la charger explicitement avec : library(ggplot2) Dans ce qui suit on utilisera le jeu de données issu du recensement de la population de 2012 inclus dans l’extension questionr (résultats partiels concernant les communes de plus de 2000 habitants de France métropolitaine). On charge ces données et on en extrait les données de 5 départements (l’utilisation de la fonction filter sera expliquée dans la section 9.2.2 de la partie sur dplyr : library(questionr) data(rp2012) rp &lt;- filter(rp2012, departement %in% c(&quot;Oise&quot;, &quot;Rhône&quot;, &quot;Hauts-de-Seine&quot;, &quot;Lozère&quot;, &quot;Bouches-du-Rhône&quot;)) 8.2 Initialisation Un graphique ggplot2 s’initialise à l’aide de la fonction ggplot(). Les données représentées graphiquement sont toujours issues d’un tableau de données (data frame ou tibble), qu’on passe en argument data à la fonction : ggplot(data = rp) ## Ou, équivalent ggplot(rp) On a défini la source de données, il faut maintenant ajouter des éléments de représentation graphique. On parle de geom, qui s’ajoute à l’objet graphique de base avec l’opérateur +. Un des geom les plus simples est geom_histogram. On peut l’ajouter de la manière suivante : ggplot(rp) + geom_histogram() Reste à indiquer quelle donnée nous voulons représenter sous forme d’histogramme. Cela se fait à l’aide d’arguments passés via la fonction aes(). Ici nous avons un paramètre à renseigner, x, qui indique la variable à représenter (sur l’axe des x). Par exemple : ggplot(rp) + geom_histogram(aes(x = cadres)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Si on veut représenter une autre variable, il suffit de changer la valeur de x : ggplot(rp) + geom_histogram(aes(x = ouvr)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Inutile d’indiquer le nom du data frame sous la forme rp$ouvr, car ggplot2 recherche automatiquement la variable dans le tableau de données indiqué via le paramètre data. Certains geom prennent plusieurs paramètres. Ainsi, si on veut représenter un nuage de points avec geom_point, il faut indiquer à la fois la position en x et en y de ces points. On passe alors ces deux arguments à aes() : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) On peut modifier certains attributs graphiques d’un geom en lui passant des arguments supplémentaires. Par exemple, pour un nuage de points, on peut modifier la couleur des points avec l’argument color, leur taille avec l’argument size, et leur transparence avec l’argument alpha : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres), color = &quot;darkgreen&quot;, size = 3, alpha = 0.3) 8.3 Exemples de geom Il existe un grand nombre de geom, décrits en détail dans la documentation officielle. Outre geom_histogram et geom_point, on pourra noter les geom suivants. 8.3.1 geom_boxplot Permet de représenter des boîtes à moustaches. On lui passe en y la variable dont on veut étudier la répartition, et en x la variable contenant les classes qu’on souhaite comparer. ggplot(rp) + geom_boxplot(aes(x = departement, y = maison)) À noter que dans ce cas, x doit être une variable qualitative, et y une variable numérique. On peut personnaliser la présentation avec différents argument supplémentaires : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison), fill = &quot;wheat&quot;, color = &quot;tomato4&quot;) 8.3.2 geom_violin Très semblable à geom_boxplot, mais utilise des graphes en violon. ggplot(rp) + geom_violin(aes(x = departement, y = maison)) 8.3.3 geom_bar Graphique en bâtons (barplot). On lui passe en x la variable qualitative dont on souhaite représenter l’effectif de chaque modalité. ggplot(rp) + geom_bar(aes(x = departement)) Un cas assez fréquent mais un peu plus complexe survient quand on a déjà calculé le tri à plat de la variable à représenter auparavant. Dans ce cas on souhaite que geom_bar représente les effectifs sans les calculer : cela se fait en indiquant un mappage y pour le variable contenant les effectifs, et en ajoutant l’argument stat=&quot;identity&quot;. Ainsi si on a les données sous cette forme : # A tibble: 5 x 2 departement n &lt;fctr&gt; &lt;int&gt; 1 Bouches-du-Rhône 98 2 Hauts-de-Seine 35 3 Lozère 5 4 Oise 75 5 Rhône 119 On peut obtenir le graphique souhaité ainsi : ggplot(df) + geom_bar(aes(x = departement, y = n), stat=&quot;identity&quot;) On peut également modifier l’apparence du graphique avec des argument supplémentaires comme fill ou width : ggplot(rp) + geom_bar(aes(x = departement), fill = &quot;darkblue&quot;, width = .5) 8.3.4 geom_text Représente des points identifiés par des labels. On doit lui passer x et y pour la position des points, et label pour le contenu des étiquettes. ggplot(rp) + geom_text(aes(x = dipl_sup, y = cadres, label = commune)) On peut personnaliser l’apparence et la position du texte avec des arguments comme size, color, etc. ggplot(rp) + geom_text(aes(x = dipl_sup, y = cadres, label = commune), color = &quot;darkred&quot;, size = 2) 8.3.5 geom_label Identique à geom_text, mais avec une présentation différente. ggplot(rp) + geom_label(aes(x = dipl_sup, y = cadres, label = commune)) 8.3.6 geom_density Estimation de densité d’une variable numérique. Usage similaire à geom_histogram. ggplot(rp) + geom_density(aes(x = cadres)) 8.3.7 geom_line Trace des lignes connectant les différentes observations. geom_line connecte les observations selon l’ordre de la variable passée en x. data(&quot;economics&quot;) ggplot(economics) + geom_line(aes(x = date, y = unemploy)) 8.4 Représentation de plusieurs geom On peut représenter plusieurs geom simultanément sur un même graphique. Par exemple, on peut superposer la position des points au-dessus des boîtes à moustaches : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison)) + geom_point(aes(x = departement, y = maison), col = &quot;red&quot;, alpha = 0.2) Pour un résultat un peu plus lisible, on peut remplacer geom_point par geom_jitter, qui disperse les points horizontalement et facilite leur visualisation : ggplot(rp) + geom_boxplot(aes(x = departement, y = maison)) + geom_jitter(aes(x = departement, y = maison), col = &quot;red&quot;, alpha = 0.2) Dans ce cas, plutôt que de déclarer les mappages dans chaque geom, on peut les déclarer dans l’appel à ggplot(). Ils seront automatiquement “hérités” par les geom ajoutés (sauf s’ils redéfinissent les mêmes mappages) : ggplot(rp, aes(x = departement, y = maison)) + geom_boxplot() + geom_jitter(color = &quot;red&quot;, alpha = 0.2) Autre exemple, on peut vouloir ajouter à un nuage de points une ligne de régression linéaire à l’aide de geom_smooth : ggplot(rp, aes(x = dipl_sup, y = cadres)) + geom_point(alpha = 0.2) + geom_smooth(method = &quot;lm&quot;) Et on peut même superposer une troisième visualisation de la répartition des points dans l’espace avec geom_density2d : ggplot(rp, aes(x = dipl_sup, y = cadres)) + geom_point(alpha = 0.2) + geom_density2d(color = &quot;red&quot;) + geom_smooth(method = &quot;lm&quot;) 8.4.1 Plusieurs sources de données On peut aussi associer à différents geom des sources de données différentes via l’argument data. Supposons qu’on souhaite afficher les noms des communes de plus de 50000 habitants. On peut commencer par créer un tableau de données avec seulement ces communes : com50 &lt;- filter(rp, pop_tot &gt;= 50000) On fait ensuite le nuage de points comme habituellement, et on ajoute un geom_text dont les données sont tirées de ce nouveau data frame : ggplot(data = rp, aes(x = dipl_sup, y = cadres)) + geom_point(alpha = 0.2) + geom_text(data = com50, aes(label = commune), color = &quot;red&quot;, size = 3) 8.5 Mappages (aesthetics) Un mappage est une mise en relation entre un attribut graphique du geom (position, couleur, taille…) et une variable du tableau de données. Ces mappages sont passés aux différents geom via la fonction aes() (abbréviation d’aesthetic). 8.5.1 Exemples de mappages On a déjà vu les mappages x et y pour un nuage de points. Ceux-ci signifient que la position d’un point donné horizontalement (x) et verticalement (y) depend de la valeur des variables passées comme arguments x et y dans aes() : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) On peut en ajouter d’autres. Par exemple, color permet de faire varier la couleur des points automatiquement en fonction des valeurs d’une troisième variable : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement)) On peut faire varier la taille des points avec size : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot)) Ou même leur transparence avec alpha : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = departement, size = pop_tot, alpha = maison)) Chaque geom possède sa propre liste de mappages. 8.5.2 aesthetic or not aesthetic ? Parfois on souhaite changer un attribut sans le relier à une variable. Par exemple, on veut représenter tous les points en rouge. Dans ce cas on utilise toujours l’attribut color, mais comme il ne s’agit pas d’un mappage, on le définit à l’extérieur de la fonction aes() : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres), color = &quot;red&quot;) On peut évidemment mélanger attributs liés à une variable (dans aes()) et attributs constants (à l’extérieur) : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot), color = &quot;royalblue&quot;, alpha = 0.3) La règle est donc simple mais très importante : Si on établit un lien entre les valeurs d’une variable et un attribut graphique, on définit un mappage, et on le déclare dans aes(). Sinon, on modifie l’attribut de la même manière pour tous les points, et on le définit donc en-dehors de la fonction aes(). 8.5.3 geom_bar et position Un des mappages possibles de geom_bar est l’attribut fill, qui permet de tracer des barres de couleur différentes selon les modalités d’une variable : ggplot(rp) + geom_bar(aes(x = departement, fill = pop_cl)) L’attribut position de geom_bar permet d’indiquer comment les différentes barres doivent être positionnées. Par défaut on a position = &quot;stack&quot; et elles sont donc “empilées”. Mais on peut préciser position = &quot;dodge&quot; pour les mettre côte à côte : ggplot(rp) + geom_bar(aes(x = departement, fill = pop_cl), position = &quot;dodge&quot;) Ou encore position = &quot;fill&quot; pour représenter non plus des effectifs, mais des proportions : ggplot(rp) + geom_bar(aes(x = departement, fill = pop_cl), position = &quot;fill&quot;) 8.6 facets Le faceting permet d’effectuer plusieurs fois le même graphique selon les valeurs d’une ou plusieurs variables qualitatives. Par exemple, on peut représenter l’histogramme du pourcentage de cadres : ggplot(data = rp) + geom_histogram(aes(x = cadres)) Mais on peut vouloir faire un histogramme pour chaque département. On peut dans ce cas utiliser facet_wrap ou facet_grid. Les deux fonctions prennent en paramètre une formule. Pour facet_wrap, les différents graphiques sont affichés les uns à côté des autres et répartis automatiquement dans la page. La formule prend la forme ~variable : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + facet_wrap(~departement) Pour facet_grid, les graphiques sont disposés selon une grille. La formule est de la forme variable en ligne ~ variable en colonne. Si on n’a pas de variable dans l’une des deux dimensions, on met un point (.) : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + facet_grid(.~departement) Enfin, on peut même faire du faceting sur plusieurs variables à la fois : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + facet_grid(pop_cl~departement) 8.7 scales Dans ggplot2, on appelle scales la manière dont un attribut graphique va être relié aux valeurs d’une variable et dont la légende correspondante va être affichée. Par exemple, pour color, on définira la palette de couleur utilisée. Pour size, les tailles minimales et maximales, etc. Pour modifier une scale existante, on ajoute un nouvel élément à notre objet ggplot2, qui prendra la forme scale_&lt;attribut&gt;_&lt;type&gt;. 8.7.1 scale_size Par exemple, si on souhaite modifier les tailles minimales et maximales des objets quand on a effectué un mappage de type size, on peut utiliser : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) + scale_size(range = c(0,15)) On peut ajouter d’autres paramètres. Le premier argument est toujours le titre donné à la légende : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) + scale_size(&quot;Population&quot;, range = c(0,15)) On peut aussi, de la même manière, définir manuellement les éléments de légende représentés : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, size = pop_tot)) + scale_size(&quot;Population&quot;, range = c(0,15), breaks = c(1000,5000,10000,50000)) 8.7.2 scale_x_*, scale_y_* Les scales scale_x et scale_y modifient les axes x et y du graphique. scale_x_continuous et scale_y_continuous s’appliquent lorsque la variable x ou y est numérique (quantitative). ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) + scale_x_continuous(&quot;Diplômés du supérieur&quot;, limits = c(0,100)) On peut utiliser scale_x_log10 et scale_y_log10 pour passer un axe à une échelle logarithmique : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres)) + scale_x_log10(&quot;Diplômés du supérieur&quot;) scale_x_discrete et scale_y_discrete s’appliquent lorsque l’axe correspond à une variable discrète (qualitative) : ggplot(rp) + geom_bar(aes(x = departement)) + scale_x_discrete(&quot;Département&quot;) L’argument limits permet d’indiquer quelles valeurs sont affichées et dans quel ordre. ggplot(rp) + geom_bar(aes(x = departement)) + scale_x_discrete(&quot;Département&quot;, limits = c(&quot;Oise&quot;, &quot;Lozère&quot;, &quot;Seine-Saint-Denis&quot;)) Warning: Removed 252 rows containing non-finite values (stat_count). 8.7.3 scale_color_*, scale_fill_* Ces scales permettent entre autre de modifier les palettes de couleur utilisées pour le dessin (color) ou le remplissage (fill). Si on colore des points selon une variable numérique : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = chom)) On peut modifier les couleurs utilisées avec scale_*_gradient : ggplot(rp) + geom_point(aes(x = dipl_sup, y = cadres, color = chom)) + scale_color_gradient(&quot;Taux de chômage&quot;, low = &quot;white&quot;, high = &quot;red&quot;) Si on a fait un mappage avec une variable discrète : ggplot(rp) + geom_density(aes(x = cadres, fill = departement), alpha = 0.5) On peut modifier la palette notamment avec scale_*_manual, scale_*_hue : ggplot(rp) + geom_density(aes(x = cadres, fill = departement), alpha = 0.5) + scale_fill_manual(&quot;Département&quot;, values = c(&quot;red&quot;, &quot;#FFDD45&quot;, rgb(0.1,0.2,0.6), &quot;darkgreen&quot;, &quot;grey80&quot;)) Les scales scale_*_brewer sont très pratiques, elles récupèrent des palettes depuis le site Colorbrewer. Les palettes en question, initialement prévues pour la cartographie, permettent une bonne lisibilité, et peuvent être adaptées pour certains types de daltonisme. ggplot(rp) + geom_density(aes(x = cadres, fill = departement), alpha = 0.5) + scale_fill_brewer(&quot;Département&quot;, palette = &quot;Accent&quot;) Il existe de nombreuses autres méthodes pour définir les couleurs, se reporter à la documentation officielle. 8.8 Thèmes Les thèmes permettent de contrôler l’affichage de tous les éléments du graphique qui ne sont pas reliés aux données : titres, grilles, fonds, etc. Il existe un certain nombre de thèmes préexistants : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + theme_bw() `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ggplot(data = rp) + geom_histogram(aes(x = cadres)) + theme_minimal() `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Mais tous les éléments sont personnalisables. Un bon moyen de se familiariser avec tous les arguments est sans doute l’addin RStudio ggThemeAssist. Pour cela il suffit d’installer le package en question, de sélectionner dans son script RStudio le code correspondant à un graphique ggplot2, puis d’aller dans le menu Addins et choisir ggplot Theme Assistant. Une interface graphique s’affiche alors permettant de modifier les différents éléments. Si on clique sur Done, le code dans le script est alors automatiquement mis à jour par le code correspondant aux modifications effectuées. Ce qui permet d’obtenir très facilement des résultats extrêmement moches : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + theme(panel.grid.major = element_line(colour = &quot;dodgerblue&quot;, size = 0.5, linetype = &quot;dotdash&quot;), axis.title = element_text(family = &quot;serif&quot;, size = 18, face = &quot;italic&quot;, colour = &quot;white&quot;), axis.text = element_text(family = &quot;serif&quot;, size = 15, face = &quot;bold&quot;), axis.text.x = element_text(family = &quot;mono&quot;), plot.title = element_text(family = &quot;serif&quot;), legend.text = element_text(family = &quot;serif&quot;), legend.title = element_text(family = &quot;serif&quot;), panel.background = element_rect(fill = &quot;coral&quot;), plot.background = element_rect(fill = &quot;blueviolet&quot;)) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Enfin, les fonctions ggtitle, xlab et ylab permettent d’ajouter ou de modifier facilement un titre de graphique, ainsi que ceux des étiquettes des axes x et y : ggplot(data = rp) + geom_histogram(aes(x = cadres)) + ggtitle(&quot;Un bien bel histogramme&quot;) + xlab(&quot;Pourcentage de cadres&quot;) + ylab(&quot;Effectif&quot;) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 8.9 Ressources La documentation officielle (en anglais) de ggplot2 est très complète et accessible en ligne : http://ggplot2.tidyverse.org/index.html Une “antisèche” (en anglais) résumant en deux pages l’ensemble des fonctions et arguments et disponible soit directement depuis RStudio (menu Help &gt; Chetasheets &gt; Data visualization with ggplot2) ou en ligne à l’adresse suivante : https://www.rstudio.com/resources/cheatsheets/ La partie Data visualisation de l’ouvrage en ligne R for data science, de Hadley Wickham, est une très bonne introduction à ggplot2 : http://r4ds.had.co.nz/data-visualisation.html Enfin, plusieurs ouvrages, toujours en anglais, abordent en détail l’utilisation de ggplot2, en particulier ggplot2: Elegant Graphics for Data Analysis, de Hadley Wickham : http://www.amazon.fr/ggplot2-Elegant-Graphics-Data-Analysis/dp/0387981403/ Et le R Graphics Cookbook de Winston Chang : http://www.amazon.fr/R-Graphics-Cookbook-Winston-Chang/dp/1449316956 Le site associé à ce dernier ouvrage comporte aussi pas mal d’exemples et d’informations intéressantes : http://www.cookbook-r.com/Graphs/ 8.10 Exercices Pour les exercices qui suivent, on commence par charger les extensions nécessaires et les données du jeu de données rp2012. On crée alors un objet rp69 comprenant uniquement les communes du Rhône et de la Loire. library(tidyverse) library(questionr) data(rp2012) rp69 &lt;- filter(rp2012, departement %in% c(&quot;Rhône&quot;, &quot;Loire&quot;)) Exercice 1 Faire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers. Exercice 2 Faire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers, avec les points en rouge et de transparence 0.2. Exercice 3 Représenter la répartition du pourcentage de propriétaires selon la taille de la commune en 5 classes (variable pop_cl) sous forme de boîtes à moustache. Exercice 4 Représenter la répartition du nombre de communes selon la taille de la commune en 5 classes sous forme de diagramme en bâtons. Exercice 5 Faire un nuage de points croisant le pourcentage de sans diplôme et le pourcentage d’ouvriers. Faire varier la couleur selon le département et la taille selon la population totale. Mettre une transparence de 0.5. Exercice 6 Représenter la répartition du nombre de communes selon la taille de la commune en 5 classes sous forme de diagramme en bâtons, avec une couleur différente selon le département. Faire varier la valeur du paramètre position pour afficher les barres les unes à côté des autres. Changer à nouveau la valeur du paramètre position pour représenter les proportions de communes de chaque département pour chaque catégorie de taille. Exercice 7 Faire le nuage de points du pourcentage de cadres par le pourcentage de diplômés du supérieur. Représenter ce nuage par deux graphiques différents selon le département en utilisant facet_grid. Exercice 8 Faire le nuage de points croisant pourcentage de chômeurs et pourcentage de sans diplôme. Y ajouter les noms des communes correspondant, en rouge et en taille 2.5 : Exercice 9 Dans le graphique précédent, n’afficher que le nom des communes ayant plus de 15% de chômage. "],
["09-dplyr.html", "Partie 9 Manipuler les données 9.1 Préparation 9.2 Les verbes de dplyr 9.3 Enchaîner les opérations avec le pipe : %&gt;% 9.4 Opérations groupées 9.5 Autres fonctions utiles 9.6 Tables multiples 9.7 Ressources 9.8 Exercices", " Partie 9 Manipuler les données dplyr est une extension facilitant le traitement et la manipulation de données contenues dans une ou plusieurs tables (qu’il s’agisse de data frame ou de tibble). Elle propose une syntaxe claire et cohérente, sous formes de verbes, pour la plupart des opérations de ce type. Par ailleurs, les fonctions de dlpyr sont en général plus rapides que leur équivalent sous R de base, elles permettent donc de traiter des données de grande dimension. 9.1 Préparation dplyr fait partie du tidyverse, elle est donc chargée automatiquement avec : library(tidyverse) On peut également la charger explicitement avec : library(dplyr) Dans ce qui suit on utilisera les données du jeu de données nycflights13. Celui-ci correspond aux données de tous les vols au départ d’un des trois aéroports de NEw-York en 2013. Il est réparti en trois tables : flights contient des informations sur le vol : date, départ, destination, horaires, retard… airports contient des informations sur les aéroports airlines contient des données sur les compagnies aériennes On va charger les trois tables du jeu de données : library(nycflights13) ## Chargement des trois tables du jeu de données data(flights) data(airports) data(airlines) 9.2 Les verbes de dplyr La manipulation de données avec dplyr se fait en utilisant un nombre réduit de verbes, qui correspondent chacun à une action différente appliquée à un tableau de données. 9.2.1 slice Le verbe slice sélectionne des lignes du tableau selon leur position. On lui passe un chiffre ou un vecteur de chiffres. Si on souhaite sélectionner la 345e ligne du tableau airports : slice(airports, 345) # A tibble: 1 x 8 faa name lat lon alt tz dst &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; 1 CYF Chefornak Airport 60.14917 -164.2856 40 -9 A # ... with 1 more variables: tzone &lt;chr&gt; Si on veut sélectionner les 5 premières lignes : slice(airports, 1:5) # A tibble: 5 x 8 faa name lat lon alt tz dst &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; 1 04G Lansdowne Airport 41.13047 -80.61958 1044 -5 A 2 06A Moton Field Municipal Airport 32.46057 -85.68003 264 -6 A 3 06C Schaumburg Regional 41.98934 -88.10124 801 -6 A 4 06N Randall Airport 41.43191 -74.39156 523 -5 A 5 09J Jekyll Island Airport 31.07447 -81.42778 11 -5 A # ... with 1 more variables: tzone &lt;chr&gt; 9.2.2 filter filter sélectionne des lignes d’un tableau de données selon une condition. On lui passe en paramètre un test, et seules les lignes pour lesquelles ce test renvoie vrai sont conservées.12 Si on veut choisir les vols du mois de janvier : filter(flights, month == 1) # A tibble: 27,004 x 19 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 1 517 515 2 830 2 2013 1 1 533 529 4 850 3 2013 1 1 542 540 2 923 4 2013 1 1 544 545 -1 1004 5 2013 1 1 554 600 -6 812 6 2013 1 1 554 558 -4 740 7 2013 1 1 555 600 -5 913 8 2013 1 1 557 600 -3 709 9 2013 1 1 557 600 -3 838 10 2013 1 1 558 600 -2 753 # ... with 26,994 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Si on veut les vols avec un retard au départ compris entre 10 et 15 minutes : filter(flights, dep_delay &gt;= 10 &amp; dep_delay &lt;= 15) # A tibble: 14,919 x 19 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 1 611 600 11 945 2 2013 1 1 623 610 13 920 3 2013 1 1 743 730 13 1107 4 2013 1 1 743 730 13 1059 5 2013 1 1 851 840 11 1215 6 2013 1 1 912 900 12 1241 7 2013 1 1 914 900 14 1058 8 2013 1 1 920 905 15 1039 9 2013 1 1 1011 1001 10 1133 10 2013 1 1 1112 1100 12 1440 # ... with 14,909 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Si on passe plusieurs arguments à filter, celui-ci rajoute automatiquement une condition et. La ligne ci-dessus peut donc également être écrite de la manière suivante, avec le même résultat : filter(flights, dep_delay &gt;= 10, dep_delay &lt;= 15) 9.2.3 select et rename select permet de sélectionner des colonnes d’un tableau de données. Ainsi, si on veut extraire les colonnes latet lon du tableau airports : select(airports, lat, lon) # A tibble: 1,458 x 2 lat lon &lt;dbl&gt; &lt;dbl&gt; 1 41.13047 -80.61958 2 32.46057 -85.68003 3 41.98934 -88.10124 4 41.43191 -74.39156 5 31.07447 -81.42778 6 36.37122 -82.17342 7 41.46731 -84.50678 8 42.88356 -76.78123 9 39.79482 -76.64719 10 48.05381 -122.81064 # ... with 1,448 more rows Si on fait précéder le nom d’un -, la colonne est éliminée plutôt que sélectionnée : select(airports, -lat, -lon) # A tibble: 1,458 x 6 faa name alt tz dst &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; 1 04G Lansdowne Airport 1044 -5 A 2 06A Moton Field Municipal Airport 264 -6 A 3 06C Schaumburg Regional 801 -6 A 4 06N Randall Airport 523 -5 A 5 09J Jekyll Island Airport 11 -5 A 6 0A9 Elizabethton Municipal Airport 1593 -5 A 7 0G6 Williams County Airport 730 -5 A 8 0G7 Finger Lakes Regional Airport 492 -5 A 9 0P2 Shoestring Aviation Airfield 1000 -5 U 10 0S9 Jefferson County Intl 108 -8 A # ... with 1,448 more rows, and 1 more variables: tzone &lt;chr&gt; select comprend toute une série de fonctions facilitant la sélection de multiples colonnes. Par exemple, starts_with, ends_width, contains ou matches permettent d’exprimer des conditions sur les noms de variables : select(airports, starts_with(&quot;dep_&quot;)) # A tibble: 1,458 x 0 select peut être utilisée pour réordonner les colonnes d’une table. Par exemple, si on souhaite faire passer la colonne name en première position de la table airports, on peut faire : select(airports, name, everything()) # A tibble: 1,458 x 8 name faa lat lon alt tz &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; 1 Lansdowne Airport 04G 41.13047 -80.61958 1044 -5 2 Moton Field Municipal Airport 06A 32.46057 -85.68003 264 -6 3 Schaumburg Regional 06C 41.98934 -88.10124 801 -6 4 Randall Airport 06N 41.43191 -74.39156 523 -5 5 Jekyll Island Airport 09J 31.07447 -81.42778 11 -5 6 Elizabethton Municipal Airport 0A9 36.37122 -82.17342 1593 -5 7 Williams County Airport 0G6 41.46731 -84.50678 730 -5 8 Finger Lakes Regional Airport 0G7 42.88356 -76.78123 492 -5 9 Shoestring Aviation Airfield 0P2 39.79482 -76.64719 1000 -5 10 Jefferson County Intl 0S9 48.05381 -122.81064 108 -8 # ... with 1,448 more rows, and 2 more variables: dst &lt;chr&gt;, tzone &lt;chr&gt; Une variante de select est rename, qui permet de renommer facilement des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom : rename(airports, longitude = lon, latitude = lat) # A tibble: 1,458 x 8 faa name latitude longitude alt tz &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; 1 04G Lansdowne Airport 41.13047 -80.61958 1044 -5 2 06A Moton Field Municipal Airport 32.46057 -85.68003 264 -6 3 06C Schaumburg Regional 41.98934 -88.10124 801 -6 4 06N Randall Airport 41.43191 -74.39156 523 -5 5 09J Jekyll Island Airport 31.07447 -81.42778 11 -5 6 0A9 Elizabethton Municipal Airport 36.37122 -82.17342 1593 -5 7 0G6 Williams County Airport 41.46731 -84.50678 730 -5 8 0G7 Finger Lakes Regional Airport 42.88356 -76.78123 492 -5 9 0P2 Shoestring Aviation Airfield 39.79482 -76.64719 1000 -5 10 0S9 Jefferson County Intl 48.05381 -122.81064 108 -8 # ... with 1,448 more rows, and 2 more variables: dst &lt;chr&gt;, tzone &lt;chr&gt; Si les noms de colonnes comportent des espaces ou des caractères spéciaux, on peut les entourer de guillemets (&quot;) ou de quotes inverses (`). 9.2.4 arrange arrange réordonne les lignes d’un tableau selon une ou plusieurs colonnes. Ainsi, si on veut trier le tableau flights selon le retard au départ croissant : arrange(flights, dep_delay) # A tibble: 336,776 x 19 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 12 7 2040 2123 -43 40 2 2013 2 3 2022 2055 -33 2240 3 2013 11 10 1408 1440 -32 1549 4 2013 1 11 1900 1930 -30 2233 5 2013 1 29 1703 1730 -27 1947 6 2013 8 9 729 755 -26 1002 7 2013 10 23 1907 1932 -25 2143 8 2013 3 30 2030 2055 -25 2213 9 2013 3 2 1431 1455 -24 1601 10 2013 5 5 934 958 -24 1225 # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; On peut trier selon plusieurs colonnes. Par exemple selon le mois, puis selon le retard au départ : arrange(flights, month, dep_delay) # A tibble: 336,776 x 19 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 11 1900 1930 -30 2233 2 2013 1 29 1703 1730 -27 1947 3 2013 1 12 1354 1416 -22 1606 4 2013 1 21 2137 2159 -22 2232 5 2013 1 20 704 725 -21 1025 6 2013 1 12 2050 2110 -20 2310 7 2013 1 12 2134 2154 -20 4 8 2013 1 14 2050 2110 -20 2329 9 2013 1 4 2140 2159 -19 2241 10 2013 1 11 1947 2005 -18 2209 # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Si on veut trier selon une colonne par ordre décroissant, on lui applique la fonction desc() : arrange(flights, desc(dep_delay)) # A tibble: 336,776 x 19 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 6 15 1432 1935 1137 1607 3 2013 1 10 1121 1635 1126 1239 4 2013 9 20 1139 1845 1014 1457 5 2013 7 22 845 1600 1005 1044 6 2013 4 10 1100 1900 960 1342 7 2013 3 17 2321 810 911 135 8 2013 6 27 959 1900 899 1236 9 2013 7 22 2257 759 898 121 10 2013 12 5 756 1700 896 1058 # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Combiné avec slice, arrange permet par exemples de sélectionner les trois vols ayant eu le plus de retard : flights &lt;- arrange(flights, desc(dep_delay)) slice(flights, 1:3) # A tibble: 3 x 19 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 6 15 1432 1935 1137 1607 3 2013 1 10 1121 1635 1126 1239 # ... with 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, # time_hour &lt;dttm&gt; 9.2.5 mutate mutate permet de créer de nouvelles colonnes dans le tableau de données à partir des variables existantes. Par exemple, la table airports contient l’altitude de l’aéroport en pieds. Si on veut créer une nouvelle variable avec l’altitude en mètres : airports &lt;- mutate(airports, alt_m = alt / 3.2808) select(airports, name, alt, alt_m) # A tibble: 1,458 x 3 name alt alt_m &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 Lansdowne Airport 1044 318.215069 2 Moton Field Municipal Airport 264 80.468178 3 Schaumburg Regional 801 244.147769 4 Randall Airport 523 159.412338 5 Jekyll Island Airport 11 3.352841 6 Elizabethton Municipal Airport 1593 485.552304 7 Williams County Airport 730 222.506706 8 Finger Lakes Regional Airport 492 149.963424 9 Shoestring Aviation Airfield 1000 304.803706 10 Jefferson County Intl 108 32.918800 # ... with 1,448 more rows On peut indiquer plusieurs nouvelles colonnes en une seule fois, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. flights &lt;- mutate(flights, distance_km = distance / 0.62137, vitesse = distance_km / air_time * 60) select(flights, distance, distance_km, vitesse) # A tibble: 336,776 x 3 distance distance_km vitesse &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 4983 8019.3765 751.8166 2 483 777.3146 630.2551 3 719 1157.1206 625.4706 4 2586 4161.7716 705.3850 5 589 947.9054 592.4409 6 1005 1617.3938 698.1556 7 1020 1641.5340 589.7727 8 2454 3949.3378 757.0616 9 762 1226.3225 675.0399 10 1085 1746.1416 703.1443 # ... with 336,766 more rows 9.3 Enchaîner les opérations avec le pipe : %&gt;% Quand on manipule un tableau de données, il est fréquent d’enchaîner plusieurs opérations. On va par exemple filtrer une sous-population, sélectionner des colonnes et trier selon une variable. Dans ce cas on peut le faire de deux manières différentes. La première est d’effectuer toutes les opérations en une fois en les “emboîtant” : arrange(select(filter(flights, dest == &quot;LAX&quot;), dep_delay, arr_delay), dep_delay) # A tibble: 16,174 x 2 dep_delay arr_delay &lt;dbl&gt; &lt;dbl&gt; 1 -16 -31 2 -15 4 3 -15 -4 4 -15 -22 5 -15 -29 6 -15 -20 7 -15 -25 8 -15 -35 9 -15 -17 10 -15 -7 # ... with 16,164 more rows Cette notation a plusieurs inconvénients : elle est peu lisible les opérations apparaissent dans l’ordre inverse de leur réalisation. Ici on effectue d’abord le filter, puis le select, puis le arrange, alors qu’à la lecture du code c’est le arrange qui apparaît en premier. Il est difficile de voir quel paramètre se rapporte à quelle fonction Une autre manière de faire est d’effectuer les opérations les unes après les autres, en sotckant les résultats intermédiaires dans un objet temporaire : tmp &lt;- filter(flights, dest == &quot;LAX&quot;) tmp &lt;- select(tmp, dep_delay, arr_delay) arrange(tmp, dep_delay) # A tibble: 16,174 x 2 dep_delay arr_delay &lt;dbl&gt; &lt;dbl&gt; 1 -16 -31 2 -15 4 3 -15 -4 4 -15 -22 5 -15 -29 6 -15 -20 7 -15 -25 8 -15 -35 9 -15 -17 10 -15 -7 # ... with 16,164 more rows C’est nettement plus lisible, l’ordre des opérations est le bon, et les paramètres sont bien rattachés à leur fonction. Par contre, ça reste un peu “verbeux”, et on crée un objet temporaire dont on n’a pas réellement besoin. Pour simplifier et améliorer encore la lisibilité du code, on va utiliser un nouvel opérateur, baptisé pipe.13 Le pipe se note %&gt;%, et son fonctionnement est le suivant : si j’exécute expr %&gt;% f, alors le résultat de l’expression expr, à gauche du pipe, sera passé comme premier argument à la fonction f, à droite du pipe, ce qui revient à exécuter f(expr). Ainsi les deux expressions suivantes sont rigoureusement équivalentes : filter(flights, dest == &quot;LAX&quot;) # A tibble: 16,174 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 3 18 1020 2100 800 1336 2 2013 7 10 2334 1300 634 NA 3 2013 5 1 9 1655 434 308 4 2013 7 10 2348 1655 413 305 5 2013 12 21 1520 848 392 1808 6 2013 8 18 1932 1300 392 2239 7 2013 4 10 229 2025 364 546 8 2013 7 16 32 1830 362 301 9 2013 4 25 2245 1700 345 144 10 2013 7 10 2318 1735 343 200 # ... with 16,164 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; flights %&gt;% filter(dest == &quot;LAX&quot;) # A tibble: 16,174 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 3 18 1020 2100 800 1336 2 2013 7 10 2334 1300 634 NA 3 2013 5 1 9 1655 434 308 4 2013 7 10 2348 1655 413 305 5 2013 12 21 1520 848 392 1808 6 2013 8 18 1932 1300 392 2239 7 2013 4 10 229 2025 364 546 8 2013 7 16 32 1830 362 301 9 2013 4 25 2245 1700 345 144 10 2013 7 10 2318 1735 343 200 # ... with 16,164 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Ce qui est intéressant dans l’histoire, c’est qu’on va pouvoir enchaîner les pipes. Plutôt que d’écrire : select(filter(flights, dest == &quot;LAX&quot;), dep_delay, arr_delay) # A tibble: 16,174 x 2 dep_delay arr_delay &lt;dbl&gt; &lt;dbl&gt; 1 800 784 2 634 NA 3 434 408 4 413 420 5 392 362 6 392 404 7 364 373 8 362 316 9 345 319 10 343 313 # ... with 16,164 more rows On va pouvoir faire : flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) # A tibble: 16,174 x 2 dep_delay arr_delay &lt;dbl&gt; &lt;dbl&gt; 1 800 784 2 634 NA 3 434 408 4 413 420 5 392 362 6 392 404 7 364 373 8 362 316 9 345 319 10 343 313 # ... with 16,164 more rows À chaque fois, le résultat de ce qui se trouve à gauche du pipe est passé comme premier argument à ce qui se trouve à droite. Le résultat final est le même, mais l’ordre des opérations correspond à l’ordre naturel de leur exécution, et on n’a pas eu besoin de créer d’objets intermédiaires. Si la liste des fonctions enchaînées est longue, on peut les répartir sur plusieurs lignes à condition que l’opérateur %&gt;% soit en fin de ligne : flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) %&gt;% arrange(dep_delay) Enfin, on peut récupérer le résultat final de l’ensemble de la chaîne de fonctions pour, par exemple, le stocker dans un objet. On peut donc faire quelque chose comme ça : delay_la &lt;- flights %&gt;% filter(dest == &quot;LAX&quot;) %&gt;% select(dep_delay, arr_delay) %&gt;% arrange(dep_delay) Dans ce cas, delay_la contiendra le tableau final, obtenu après application des trois instructions filter, select et arrange. Cette utilisation du pipe n’est pas obligatoire, mais elle rend les scripts plus lisibles et plus rapides à saisir. On l’utilisera donc dans ce qui suit. 9.4 Opérations groupées 9.4.1 group_by Un élément très important de dplyr est la fonction group_by. Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois : flights %&gt;% group_by(month) # A tibble: 336,776 x 21 # Groups: month [12] year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 6 15 1432 1935 1137 1607 3 2013 1 10 1121 1635 1126 1239 4 2013 9 20 1139 1845 1014 1457 5 2013 7 22 845 1600 1005 1044 6 2013 4 10 1100 1900 960 1342 7 2013 3 17 2321 810 911 135 8 2013 6 27 959 1900 899 1236 9 2013 7 22 2257 759 898 121 10 2013 12 5 756 1700 896 1058 # ... with 336,766 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Par défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups lors de l’affichage. Mais à partir du moment où des groupes ont été définis, les verbes comme slice, mutate ou summarise vont en tenir compte lors de leurs calculs. Par exemple, si on applique slice à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe : flights %&gt;% group_by(month) %&gt;% slice(1) # A tibble: 12 x 21 # Groups: month [12] year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 2 10 2243 830 853 100 3 2013 3 17 2321 810 911 135 4 2013 4 10 1100 1900 960 1342 5 2013 5 3 1133 2055 878 1250 6 2013 6 15 1432 1935 1137 1607 7 2013 7 22 845 1600 1005 1044 8 2013 8 8 2334 1454 520 120 9 2013 9 20 1139 1845 1014 1457 10 2013 10 14 2042 900 702 2255 11 2013 11 3 603 1645 798 829 12 2013 12 5 756 1700 896 1058 # ... with 14 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, # time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Idem pour mutate : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont aplliquée groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard maximum du mois correspondant : flights %&gt;% group_by(month) %&gt;% mutate(max_delay_month = max(dep_delay, na.rm = TRUE)) %&gt;% select(dep_delay, month, max_delay_month) # A tibble: 336,776 x 3 # Groups: month [12] dep_delay month max_delay_month &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; 1 1301 1 1301 2 1137 6 1137 3 1126 1 1301 4 1014 9 1014 5 1005 7 1005 6 960 4 960 7 911 3 911 8 899 6 1137 9 898 7 1005 10 896 12 896 # ... with 336,766 more rows Attention : la clause group_by marche pour les verbes déjà vus précédemment, sauf pour arrange, qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE. On peut voir la différence en comparant les deux résultats suivants : flights %&gt;% group_by(month) %&gt;% arrange(desc(dep_delay)) # A tibble: 336,776 x 21 # Groups: month [12] year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 6 15 1432 1935 1137 1607 3 2013 1 10 1121 1635 1126 1239 4 2013 9 20 1139 1845 1014 1457 5 2013 7 22 845 1600 1005 1044 6 2013 4 10 1100 1900 960 1342 7 2013 3 17 2321 810 911 135 8 2013 6 27 959 1900 899 1236 9 2013 7 22 2257 759 898 121 10 2013 12 5 756 1700 896 1058 # ... with 336,766 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; flights %&gt;% group_by(month) %&gt;% arrange(desc(dep_delay), .by_group = TRUE) # A tibble: 336,776 x 21 # Groups: month [12] year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 1 10 1121 1635 1126 1239 3 2013 1 1 848 1835 853 1001 4 2013 1 13 1809 810 599 2054 5 2013 1 16 1622 800 502 1911 6 2013 1 23 1551 753 478 1812 7 2013 1 10 1525 900 385 1713 8 2013 1 1 2343 1724 379 314 9 2013 1 2 2131 1512 379 2340 10 2013 1 7 2021 1415 366 2332 # ... with 336,766 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; 9.4.2 summarise et count summarise permet d’agréger les lignes du tableau en effectuant une opération “résumée” sur une ou plusieurs colonnes. Par exemple, si on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights : flights %&gt;% summarise(retard_dep = mean(dep_delay, na.rm=TRUE), retard_arr = mean(arr_delay, na.rm=TRUE)) # A tibble: 1 x 2 retard_dep retard_arr &lt;dbl&gt; &lt;dbl&gt; 1 12.63907 6.895377 Cette fonction est en général utilisée avec group_by, puisqu’elle permet du coup d’agréger et résumer les lignes du tableau groupe par groupe. Si on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire : flights %&gt;% group_by(month) %&gt;% summarise(max_delay = max(dep_delay, na.rm=TRUE), min_delay = min(dep_delay, na.rm=TRUE), mean_delay = mean(dep_delay, na.rm=TRUE)) # A tibble: 12 x 4 month max_delay min_delay mean_delay &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 1301 -30 10.036665 2 2 853 -33 10.816843 3 3 911 -25 13.227076 4 4 960 -21 13.938038 5 5 878 -24 12.986859 6 6 1137 -21 20.846332 7 7 1005 -22 21.727787 8 8 520 -26 12.611040 9 9 1014 -24 6.722476 10 10 702 -25 6.243988 11 11 798 -32 5.435362 12 12 896 -43 16.576688 summarise dispose d’un opérateur spécial, n(), qui retourne le nombre de lignes du groupe. Ainsi si on veut le nombre de vols par destination : flights %&gt;% group_by(dest) %&gt;% summarise(nb = n()) %&gt;% arrange(desc(nb)) # A tibble: 105 x 2 dest nb &lt;chr&gt; &lt;int&gt; 1 ORD 17283 2 ATL 17215 3 LAX 16174 4 BOS 15508 5 MCO 14082 6 CLT 14064 7 SFO 13331 8 FLL 12055 9 MIA 11728 10 DCA 9705 # ... with 95 more rows n() peut aussi être utilisée avec filter et mutate. À noter que quand on veut compter le nombre de lignes par groupe, on peut utiliser directement la fonction count. Ainsi le code suivant est identique au précédent : flights %&gt;% count(dest) %&gt;% arrange(desc(n)) # A tibble: 105 x 2 dest n &lt;chr&gt; &lt;int&gt; 1 ORD 17283 2 ATL 17215 3 LAX 16174 4 BOS 15508 5 MCO 14082 6 CLT 14064 7 SFO 13331 8 FLL 12055 9 MIA 11728 10 DCA 9705 # ... with 95 more rows On peut également compter selon plusieurs variables : flights %&gt;% count(origin, dest) %&gt;% arrange(desc(n)) # A tibble: 224 x 3 origin dest n &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 JFK LAX 11262 2 LGA ATL 10263 3 LGA ORD 8857 4 JFK SFO 8204 5 LGA CLT 6168 6 EWR ORD 6100 7 JFK BOS 5898 8 LGA MIA 5781 9 JFK MCO 5464 10 EWR BOS 5327 # ... with 214 more rows 9.4.3 Grouper selon plusieurs variables On peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du group_by : flights %&gt;% group_by(month, dest) %&gt;% summarise(nb = n()) %&gt;% arrange(desc(nb)) # A tibble: 1,113 x 3 # Groups: month [12] month dest nb &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 8 ORD 1604 2 10 ORD 1604 3 5 ORD 1582 4 9 ORD 1582 5 7 ORD 1573 6 6 ORD 1547 7 7 ATL 1511 8 8 ATL 1507 9 8 LAX 1505 10 7 LAX 1500 # ... with 1,103 more rows On peut utiliser plusieurs opérations de groupage dans la même série de fonctions. Ainsi, si on souhaite calculer le couple origine/destination avec le nombre maximum de vols selon le mois de l’année, on devra procéder en deux étapes : d’abord grouper selon mois et destination pour calculer le nombre de vols, puis grouper uniquement selon le mois pour sélectionner la ligne avec la valeur maximale. flights %&gt;% group_by(month, origin, dest) %&gt;% summarise(nb = n()) %&gt;% group_by(month) %&gt;% filter(nb == max(nb)) # A tibble: 12 x 4 # Groups: month [12] month origin dest nb &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 1 JFK LAX 937 2 2 JFK LAX 834 3 3 JFK LAX 960 4 4 JFK LAX 935 5 5 JFK LAX 960 6 6 JFK LAX 928 7 7 JFK LAX 985 8 8 JFK LAX 979 9 9 JFK LAX 925 10 10 JFK LAX 965 11 11 JFK LAX 907 12 12 JFK LAX 947 9.5 Autres fonctions utiles dplyr contient beaucoup d’autres fonctions utiles pour la manipulation de données. 9.5.1 sample_n, sample_frac Ces verbes permettent de sélectionner un nombre de lignes ou une fraction des lignes d’un tableau aléatoirement. Ainsi si on veut choisir 5 lignes au hasard dans le tableau airports : airports %&gt;% sample_n(5) # A tibble: 5 x 9 faa name lat lon alt &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; 1 LGU Logan-Cache 41.79100 -111.85200 4457 2 FWA Fort Wayne 40.97847 -85.19514 815 3 BIF Biggs Aaf 31.84953 -106.38004 3948 4 ROC Greater Rochester Intl 43.11887 -77.67239 559 5 TRM Jacqueline Cochran Regional Airport 33.62667 -116.15967 0 # ... with 4 more variables: tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;, alt_m &lt;dbl&gt; Si on veut tirer au hasard 10% des lignes de flights : flights %&gt;% sample_frac(0.1) # A tibble: 33,678 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 11 11 1156 1200 -4 1427 2 2013 10 21 1859 1907 -8 2103 3 2013 6 8 1310 1210 60 1627 4 2013 11 7 1735 1646 49 1907 5 2013 12 8 2058 2018 40 33 6 2013 3 8 2122 2015 67 2242 7 2013 2 10 732 732 0 1034 8 2013 3 13 1851 1855 -4 2029 9 2013 8 9 NA 2140 NA NA 10 2013 11 14 825 836 -11 932 # ... with 33,668 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; 9.5.2 lead et lag lead et lag permettent de décaler les observations d’une variable d’un cran vers l’arrière (pour lead) ou vers l’avant (pour lag). lead(1:5) [1] 2 3 4 5 NA lag(1:5) [1] NA 1 2 3 4 Ceci peut être utile pour des données de type “séries temporelles”. Par exemple, on peut facilement calculer l’écart entre chaque le retard au départ de chaque vol et celui du vol précédent : flights %&gt;% mutate(dep_delay_prev = lead(dep_delay), dep_delay_diff = dep_delay - dep_delay_prev) %&gt;% select(dep_delay_prev, dep_delay, dep_delay_diff) # A tibble: 336,776 x 3 dep_delay_prev dep_delay dep_delay_diff &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1137 1301 164 2 1126 1137 11 3 1014 1126 112 4 1005 1014 9 5 960 1005 45 6 911 960 49 7 899 911 12 8 898 899 1 9 896 898 2 10 878 896 18 # ... with 336,766 more rows 9.5.3 tally tally est une fonction qui permet de compter le nombre d’observations d’un groupe : flights %&gt;% group_by(month, origin, dest) %&gt;% tally # A tibble: 2,313 x 4 # Groups: month, origin [?] month origin dest n &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 1 EWR ALB 64 2 1 EWR ATL 362 3 1 EWR AUS 51 4 1 EWR AVL 2 5 1 EWR BDL 37 6 1 EWR BNA 111 7 1 EWR BOS 430 8 1 EWR BQN 31 9 1 EWR BTV 100 10 1 EWR BUF 119 # ... with 2,303 more rows Lors de son premier appel, elle sera équivalente à un summarise(n = n()). Là où la fonction est intelligente, c’est que si on l’appelle plusieurs fois successivement, elle prendra en compte l’existence d’un n déjà calculé et effectuera automatiquement un summarise(n = sum(n)) : flights %&gt;% group_by(month, origin, dest) %&gt;% tally %&gt;% tally Using `n` as weighting variable # A tibble: 36 x 3 # Groups: month [?] month origin nn &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 1 EWR 9893 2 1 JFK 9161 3 1 LGA 7950 4 2 EWR 9107 5 2 JFK 8421 6 2 LGA 7423 7 3 EWR 10420 8 3 JFK 9697 9 3 LGA 8717 10 4 EWR 10531 # ... with 26 more rows 9.5.4 distinct distinct filtre les lignes du tableau pour ne conserver que les lignes distinctes, en supprimant toutes les lignes en double. flights %&gt;% select(day, month) %&gt;% distinct # A tibble: 365 x 2 day month &lt;int&gt; &lt;int&gt; 1 9 1 2 15 6 3 10 1 4 20 9 5 22 7 6 10 4 7 17 3 8 27 6 9 5 12 10 3 5 # ... with 355 more rows 9.5.5 do do est un verbe supplémentaire générique qui permet d’appliquer des opérations complexes aux lignes d’un tableau. 9.6 Tables multiples 9.6.1 Concaténation : bind_rows et bind_cols Les fonctions bind_rows et bind_cols permettent d’ajouter des lignes (respectivement des colonnes) à une table à partir d’une ou plusieurs autres tables. L’exemple suivant (certes très artificiel) montre l’utilisation de bind_rows : t1 &lt;- airports %&gt;% slice(1:2) t2 &lt;- airports %&gt;% slice(5:6) t3 &lt;- airports %&gt;% slice(100:101) %&gt;% select(-tz, -dst) bind_rows(t1, t2, t3, .id = &quot;source&quot;) # A tibble: 6 x 10 source faa name lat lon alt &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; 1 1 04G Lansdowne Airport 41.13047 -80.61958 1044 2 1 06A Moton Field Municipal Airport 32.46057 -85.68003 264 3 2 09J Jekyll Island Airport 31.07447 -81.42778 11 4 2 0A9 Elizabethton Municipal Airport 36.37122 -82.17342 1593 5 3 ADW Andrews Afb 38.81081 -76.86703 280 6 3 AET Allakaket Airport 66.55190 -152.62220 441 # ... with 4 more variables: tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;, alt_m &lt;dbl&gt; On remarquera que si des colonnes sont manquantes pour certaines tables, comme les colonnes tz et dst de t3, des NA sont automatiquement insérées. Le paramètre optionnel .id permet d’ajouter une colonne (ici nommée source) qui indique la table source des différentes lignes du tableau final. bind_cols fonctionne de manière similaire : t1 &lt;- flights %&gt;% slice(1:5) %&gt;% select(dep_delay, dep_time) t2 &lt;- flights %&gt;% slice(1:5) %&gt;% select(origin, dest) t3 &lt;- flights %&gt;% slice(1:5) %&gt;% select(arr_delay, arr_time) bind_cols(t1, t2, t3) # A tibble: 5 x 6 dep_delay dep_time origin dest arr_delay arr_time &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; 1 1301 641 JFK HNL 1272 1242 2 1137 1432 JFK CMH 1127 1607 3 1126 1121 EWR ORD 1109 1239 4 1014 1139 JFK SFO 1007 1457 5 1005 845 JFK CVG 989 1044 À noter que bind_cols associe les lignes uniquement par position. Les lignes des différents tableaux associés doivent donc correspondre (et leur nombre doit donc être identique). Pour associer des tables par valeur, on doit utiliser les jointures. 9.6.2 Jointures Très souvent, les données relatives à une analyse sont réparties dans plusieurs tables différentes. Dans notre exemple, on peut voir que la table flights contient uniquement les codes des aéroports de départ et d’arrivée : flights %&gt;% select(origin, dest) # A tibble: 336,776 x 2 origin dest &lt;chr&gt; &lt;chr&gt; 1 JFK HNL 2 JFK CMH 3 EWR ORD 4 JFK SFO 5 JFK CVG 6 JFK TPA 7 LGA MSP 8 JFK PDX 9 LGA ATL 10 EWR MIA # ... with 336,766 more rows Et que par ailleurs la table airports contient des informations supplémentaires relatives à ces aéroports, dont le nom complet, les coordonnées géographiques, etc. airports # A tibble: 1,458 x 9 faa name lat lon alt tz &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; 1 04G Lansdowne Airport 41.13047 -80.61958 1044 -5 2 06A Moton Field Municipal Airport 32.46057 -85.68003 264 -6 3 06C Schaumburg Regional 41.98934 -88.10124 801 -6 4 06N Randall Airport 41.43191 -74.39156 523 -5 5 09J Jekyll Island Airport 31.07447 -81.42778 11 -5 6 0A9 Elizabethton Municipal Airport 36.37122 -82.17342 1593 -5 7 0G6 Williams County Airport 41.46731 -84.50678 730 -5 8 0G7 Finger Lakes Regional Airport 42.88356 -76.78123 492 -5 9 0P2 Shoestring Aviation Airfield 39.79482 -76.64719 1000 -5 10 0S9 Jefferson County Intl 48.05381 -122.81064 108 -8 # ... with 1,448 more rows, and 3 more variables: dst &lt;chr&gt;, tzone &lt;chr&gt;, # alt_m &lt;dbl&gt; Il est donc naturel de vouloir associer les deux. On peut par exemple vouloir ajouter les noms complets des aéroports à la table flights. Dans ce cas on va faire une jointure : les lignes d’une table seront associées à une autre en se basant non pas sur leur position, mais sur les valeurs d’une ou plusieurs colonnes. Ces colonnes sont appelées des clés. Commençons par créer une sous-table d’aéroports en ne conservant que la colonne name et en la renommant. On conserve également la colonne faa, qui est la clé nous permettant de faire le lien avec flights : airports_dep &lt;- airports %&gt;% select(faa, dest_name = name) airports_dep # A tibble: 1,458 x 2 faa dest_name &lt;chr&gt; &lt;chr&gt; 1 04G Lansdowne Airport 2 06A Moton Field Municipal Airport 3 06C Schaumburg Regional 4 06N Randall Airport 5 09J Jekyll Island Airport 6 0A9 Elizabethton Municipal Airport 7 0G6 Williams County Airport 8 0G7 Finger Lakes Regional Airport 9 0P2 Shoestring Aviation Airfield 10 0S9 Jefferson County Intl # ... with 1,448 more rows Et une sous-table de vols ne conservant que les colonnes year, month et day, et la clé `dest : flights_dep &lt;- flights %&gt;% select(year, month, day, dest) flights_dep # A tibble: 336,776 x 4 year month day dest &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 2013 1 9 HNL 2 2013 6 15 CMH 3 2013 1 10 ORD 4 2013 9 20 SFO 5 2013 7 22 CVG 6 2013 4 10 TPA 7 2013 3 17 MSP 8 2013 6 27 PDX 9 2013 7 22 ATL 10 2013 12 5 MIA # ... with 336,766 more rows On peut alors joindre les deux tables en utilisant la fonction left_join : left_join(flights_dep, airports_dep, by=c(&quot;dest&quot;=&quot;faa&quot;)) # A tibble: 336,776 x 5 year month day dest dest_name &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 1 9 HNL Honolulu Intl 2 2013 6 15 CMH Port Columbus Intl 3 2013 1 10 ORD Chicago Ohare Intl 4 2013 9 20 SFO San Francisco Intl 5 2013 7 22 CVG Cincinnati Northern Kentucky Intl 6 2013 4 10 TPA Tampa Intl 7 2013 3 17 MSP Minneapolis St Paul Intl 8 2013 6 27 PDX Portland Intl 9 2013 7 22 ATL Hartsfield Jackson Atlanta Intl 10 2013 12 5 MIA Miami Intl # ... with 336,766 more rows On voit que la table résultat a bien fusionné les deux tables selon les valeurs des deux colonnes clés dest et faa. On est parti de la table flights_dep, et pour chaque ligne on a ajouté les colonnes de airports_dep pour lesquelles la valeur de faa est égale à celle de dest. L’argument by permet de spécifier les noms des clés si elles ne portent pas le même nom dans les deux tables. On peut l’omettre si c’est le cas. Dans ce cas left_join utilisera comme clés toutes les colonnes présentes dans les deux tables à la fois : airports_dep &lt;- airports %&gt;% select(dest = faa, dest_name = name) flights_dep &lt;- flights %&gt;% select(year, month, day, dest) left_join(flights_dep, airports_dep) Joining, by = &quot;dest&quot; # A tibble: 336,776 x 5 year month day dest dest_name &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 1 9 HNL Honolulu Intl 2 2013 6 15 CMH Port Columbus Intl 3 2013 1 10 ORD Chicago Ohare Intl 4 2013 9 20 SFO San Francisco Intl 5 2013 7 22 CVG Cincinnati Northern Kentucky Intl 6 2013 4 10 TPA Tampa Intl 7 2013 3 17 MSP Minneapolis St Paul Intl 8 2013 6 27 PDX Portland Intl 9 2013 7 22 ATL Hartsfield Jackson Atlanta Intl 10 2013 12 5 MIA Miami Intl # ... with 336,766 more rows À noter qu’on peut continuer à utiliser le pipe avec les fonctions de jointure : flights_dep %&gt;% left_join(airports_dep) Joining, by = &quot;dest&quot; # A tibble: 336,776 x 5 year month day dest dest_name &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 1 9 HNL Honolulu Intl 2 2013 6 15 CMH Port Columbus Intl 3 2013 1 10 ORD Chicago Ohare Intl 4 2013 9 20 SFO San Francisco Intl 5 2013 7 22 CVG Cincinnati Northern Kentucky Intl 6 2013 4 10 TPA Tampa Intl 7 2013 3 17 MSP Minneapolis St Paul Intl 8 2013 6 27 PDX Portland Intl 9 2013 7 22 ATL Hartsfield Jackson Atlanta Intl 10 2013 12 5 MIA Miami Intl # ... with 336,766 more rows 9.6.3 Types de jointures Jusqu’à présent nous avons utilisé la fonction left_join, mais il existe plusieurs types de jointures. Partons de deux tables d’exemple, personnes et voitures : personnes &lt;- data_frame(nom = c(&quot;Sylvie&quot;, &quot;Sylvie&quot;, &quot;Monique&quot;, &quot;Gunter&quot;, &quot;Rayan&quot;, &quot;Rayan&quot;), voiture = c(&quot;Twingo&quot;, &quot;Ferrari&quot;, &quot;Scenic&quot;, &quot;Lada&quot;, &quot;Twingo&quot;, &quot;Clio&quot;)) nom voiture Sylvie Twingo Sylvie Ferrari Monique Scenic Gunter Lada Rayan Twingo Rayan Clio voitures &lt;- data_frame(voiture = c(&quot;Twingo&quot;, &quot;Ferrari&quot;, &quot;Clio&quot;, &quot;Lada&quot;, &quot;208&quot;), vitesse = c(140, 280, 160, 85, 160)) voiture vitesse Twingo 140 Ferrari 280 Clio 160 Lada 85 208 160 9.6.3.1 left_join Si on fait un left_join de voitures sur personnes : left_join(personnes, voitures) Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Sylvie Ferrari 280 Monique Scenic NA Gunter Lada 85 Rayan Twingo 140 Rayan Clio 160 On voit que chaque ligne de personnes est bien présente, et qu’on lui a ajouté une ligne de voitures correspondante si elle existe. Dans le cas du Scenic, il n’y a avait pas de ligne dans voitures, donc vitesse a été mis à NA. Dans le cas de 208, présente dans voitures mais pas dans personnes, la ligne n’apparaît pas. Si on fait un left_join cette fois de personnes sur voitures, c’est l’inverse : left_join(voitures, personnes) Joining, by = &quot;voiture&quot; voiture vitesse nom Twingo 140 Sylvie Twingo 140 Rayan Ferrari 280 Sylvie Clio 160 Rayan Lada 85 Gunter 208 160 NA Cette fois c’est l’inverse. La ligne 208 est là, mais nom est à NA. Par contre Monique est absente. Et on remarquera que la ligne Twingo, présente deux fois dans personnes, a été dupliquée pour être associée aux deux lignes de données de Sylvie et Rayan. En résumé, quand on fait un left_join(x, y), toutes les lignes de x sont présentes, dupliquées si nécessaire quand elles apparaissent plusieurs fois dans y. Les lignes de y non présentes dans x disparaissent. Les lignes de x non présentes dans y se voient attribuer des NA. Intuitivement, on pourrait considérer que left_join(x, y) signifie “ramener l’information de la table y sur la table x”. En général, left_join sera le type de jointures le plus fréquemment utilisé. 9.6.3.2 right_join La jointure right_join est l’exacte symétrique de left_join, c’est-à dire que right_join(x, y) est équivalent à left_join(x,y) : right_join(personnes, voitures) Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Rayan Twingo 140 Sylvie Ferrari 280 Rayan Clio 160 Gunter Lada 85 NA 208 160 9.6.3.3 inner_join Dans le cas de inner_join(x, y), seules les lignes présentes à la fois dans x et y sont présentes (et si nécessaire dupliquées) dans la table résultat : inner_join(personnes, voitures) Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Sylvie Ferrari 280 Gunter Lada 85 Rayan Twingo 140 Rayan Clio 160 Ici la ligne 208 est absente, ainsi que le aligne Monique, qui dans le cas d’un left_join avait été conservée et s’était vue attribuer une vitesse à NA. 9.6.3.4 full_join Dans le cas de full_join(x, y), toutes les lignes de x et toutes les lignes de y sont conservées (avec des NA ajoutés si nécessaire) même si elles sont absentes de l’autre table : full_join(personnes, voitures) Joining, by = &quot;voiture&quot; nom voiture vitesse Sylvie Twingo 140 Sylvie Ferrari 280 Monique Scenic NA Gunter Lada 85 Rayan Twingo 140 Rayan Clio 160 NA 208 160 9.6.3.5 semi_join et anti_join semi_join et anti_join sont des jointures filtrantes, c’est-à-dire qu’elles sélectionnent les lignes de x sans ajouter les colonnes de y. Ainsi, semi_join ne conservera que les lignes de x pour lesquelles une ligne de y existe également, et supprimera les autres. Dans notre exemple, la ligne Monique est donc supprimée : semi_join(personnes, voitures) Joining, by = &quot;voiture&quot; nom voiture Sylvie Twingo Rayan Twingo Sylvie Ferrari Rayan Clio Gunter Lada Un anti_join fait l’inverse, il ne conserve que les lignes de x absentes de y. Dans notre exemple, on ne garde donc que la ligne Monique : anti_join(personnes, voitures) Joining, by = &quot;voiture&quot; nom voiture Monique Scenic 9.7 Ressources Toutes les ressources ci-dessous sont en anglais… Le livre R for data science, librement accessibles en ligne, contient plusieurs chapitres très complets sur la manipulation des données, notamment : Data trasformation Relational data Le site de l’extension est accessible à l’adresse : http://dplyr.tidyverse.org/. Outre une liste des fonctions et les pages d’aide associées, il contient également une introduction au package et plusieurs articles dont un sur les jointures. Enfin, une “antisèche” très synthétique est également accessible depuis RStudio, en allant dans le menu Help puis Cheatsheets et Data Transformation with dplyr. 9.8 Exercices On commence par charger les extensions et les données nécessaires. library(tidyverse) library(nycflights13) 9.8.1 Les verbes de base de dplyr Exercice 1.1 Sélectionner les lignes 100 à 105 du tableau des vols (flights). # A tibble: 6 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 9 26 2211 1509 422 16 2 2013 12 29 2400 1700 420 302 3 2013 3 8 1732 1032 420 1906 4 2013 6 25 1600 900 420 1739 5 2013 6 7 2359 1700 419 201 6 2013 6 17 1259 600 419 1515 # ... with 14 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, # time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Exercice 1.2 Sélectionnez les vols du mois de juillet (variable month). # A tibble: 29,425 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 7 22 845 1600 1005 1044 2 2013 7 22 2257 759 898 121 3 2013 7 7 2123 1030 653 17 4 2013 7 10 2334 1300 634 NA 5 2013 7 7 2059 1030 629 106 6 2013 7 6 149 1600 589 456 7 2013 7 21 1555 615 580 1955 8 2013 7 10 2346 1410 576 141 9 2013 7 27 1456 600 536 1649 10 2013 7 28 6 1600 486 231 # ... with 29,415 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Sélectionnez les vols avec un retard à l’arrivée (variable arr_delay) compris entre 5 et 15 minutes. # A tibble: 36,392 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 5 7 2219 2100 79 45 2 2013 7 13 1947 1829 78 2143 3 2013 9 9 1008 852 76 1215 4 2013 5 7 2040 1929 71 2241 5 2013 5 4 1940 1830 70 2214 6 2013 6 30 2241 2131 70 58 7 2013 2 26 1719 1610 69 1930 8 2013 4 27 2141 2032 69 9 9 2013 7 17 2258 2150 68 110 10 2013 7 18 1818 1711 67 2048 # ... with 36,382 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Sélectionnez les vols des compagnies Delta, United et American (codes AA, DL et UA). filter(flights, carrier %in% c(&quot;AA&quot;, &quot;DL&quot;, &quot;UA&quot;)) # A tibble: 139,504 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 9 20 1139 1845 1014 1457 2 2013 4 10 1100 1900 960 1342 3 2013 3 17 2321 810 911 135 4 2013 6 27 959 1900 899 1236 5 2013 7 22 2257 759 898 121 6 2013 12 5 756 1700 896 1058 7 2013 5 19 713 1700 853 1007 8 2013 12 19 734 1725 849 1046 9 2013 12 17 705 1700 845 1026 10 2013 12 14 830 1845 825 1210 # ... with 139,494 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Exercice 1.3 Triez la table flights par retard au départ décroissant. # A tibble: 336,776 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 6 15 1432 1935 1137 1607 3 2013 1 10 1121 1635 1126 1239 4 2013 9 20 1139 1845 1014 1457 5 2013 7 22 845 1600 1005 1044 6 2013 4 10 1100 1900 960 1342 7 2013 3 17 2321 810 911 135 8 2013 6 27 959 1900 899 1236 9 2013 7 22 2257 759 898 121 10 2013 12 5 756 1700 896 1058 # ... with 336,766 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Exercice 1.4 Sélectionner les colonnes name, lat et lon de la table airports select(airports, name, lat, lon) Sélectionner toutes les colonnes de la table airports sauf les colonnes tz et tzone select(airports, -tz, -tzone) Toujours dans la table airports, renommer la colonne lat en latitude et lon en longitude. rename(airports, latitude = lat, longitude = lon) Exercice 1.5 Dans la table flights, créer une nouvelle variable duree_h contenant la durée du vol (variable air_time) en heures. Sélectionner dans la table obtenue uniquement les deux colonnes air_time et duree_h. tmp &lt;- mutate(flights, duree_h = air_time / 60) select(tmp, air_time, duree_h) # A tibble: 336,776 x 2 air_time duree_h &lt;dbl&gt; &lt;dbl&gt; 1 640 10.666667 2 74 1.233333 3 111 1.850000 4 354 5.900000 5 96 1.600000 6 139 2.316667 7 167 2.783333 8 313 5.216667 9 109 1.816667 10 149 2.483333 # ... with 336,766 more rows 9.8.2 Enchaîner des opérations Exercice 2.1 Réécrire le code de l’exercice précédent en utilisant le pipe %&gt;% : flights %&gt;% mutate(duree_h = air_time / 60) %&gt;% select(air_time, duree_h) # A tibble: 336,776 x 2 air_time duree_h &lt;dbl&gt; &lt;dbl&gt; 1 640 10.666667 2 74 1.233333 3 111 1.850000 4 354 5.900000 5 96 1.600000 6 139 2.316667 7 167 2.783333 8 313 5.216667 9 109 1.816667 10 149 2.483333 # ... with 336,766 more rows Exercice 2.2 Sélectionnez les vols à destination de San Francico (code SFO) et triez-les selon le retard au départ décroissant (variable dep_delay). # A tibble: 13,331 x 21 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 9 20 1139 1845 1014 1457 2 2013 7 7 2123 1030 653 17 3 2013 7 7 2059 1030 629 106 4 2013 7 6 149 1600 589 456 5 2013 7 10 133 1800 453 455 6 2013 7 10 2342 1630 432 312 7 2013 7 7 2204 1525 399 107 8 2013 7 7 2306 1630 396 250 9 2013 6 23 1833 1200 393 NA 10 2013 7 10 2232 1609 383 138 # ... with 13,321 more rows, and 14 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt; Exercice 2.3 Sélectionnez les vols des mois de septembre et octobre, conservez les colonnes dest et dep_delay, créez une nouvelle variables retard_h contenant le retard au départ en heures, triez selon retard_h par ordre décroissant et conservez uniquement les 5 premières lignes. # A tibble: 5 x 3 dest dep_delay retard_h &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 SFO 1014 16.900000 2 ATL 702 11.700000 3 DTW 696 11.600000 4 ATL 602 10.033333 5 MSP 593 9.883333 9.8.3 group_by et summarise Exercice 3.1 Affichez le nombre de vols par mois. # A tibble: 12 x 2 month n &lt;int&gt; &lt;int&gt; 1 1 27004 2 2 24951 3 3 28834 4 4 28330 5 5 28796 6 6 28243 7 7 29425 8 8 29327 9 9 27574 10 10 28889 11 11 27268 12 12 28135 Triez la table résultat selon le nombre de vols croissant. # A tibble: 12 x 2 month n &lt;int&gt; &lt;int&gt; 1 2 24951 2 1 27004 3 11 27268 4 9 27574 5 12 28135 6 6 28243 7 4 28330 8 5 28796 9 3 28834 10 10 28889 11 8 29327 12 7 29425 Exercice 3.2 Calculer le retard au départ moyen selon le mois. # A tibble: 12 x 2 month retard_moyen &lt;int&gt; &lt;dbl&gt; 1 1 10.036665 2 2 10.816843 3 3 13.227076 4 4 13.938038 5 5 12.986859 6 6 20.846332 7 7 21.727787 8 8 12.611040 9 9 6.722476 10 10 6.243988 11 11 5.435362 12 12 16.576688 Exercice 3.3 Calculer le nombre de vols à destination de Los Angeles (code LAX) pour chaque mois de l’année. # A tibble: 12 x 2 month n &lt;int&gt; &lt;int&gt; 1 1 1159 2 2 1030 3 3 1178 4 4 1382 5 5 1453 6 6 1430 7 7 1500 8 8 1505 9 9 1384 10 10 1409 11 11 1336 12 12 1408 Exercice 3.3 Calculer le nombre de vols selon le mois et la destination. # A tibble: 1,113 x 3 month dest n &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 1 ALB 64 2 1 ATL 1396 3 1 AUS 169 4 1 AVL 2 5 1 BDL 37 6 1 BHM 25 7 1 BNA 399 8 1 BOS 1245 9 1 BQN 93 10 1 BTV 223 # ... with 1,103 more rows Ne conserver, pour chaque mois, que la destination avec le nombre maximal de vols. # A tibble: 12 x 3 # Groups: month [12] month dest n &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 1 ATL 1396 2 2 ATL 1267 3 3 ATL 1448 4 4 ATL 1490 5 5 ORD 1582 6 6 ORD 1547 7 7 ORD 1573 8 8 ORD 1604 9 9 ORD 1582 10 10 ORD 1604 11 11 ATL 1384 12 12 ATL 1463 Exercice 3.4 Calculer le nombre de vols selon le mois. Ajouter une colonne comportant le pourcentage de vols annuels réalisés par mois. # A tibble: 12 x 3 month n pourcentage &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 1 27004 8.018386 2 2 24951 7.408782 3 3 28834 8.561774 4 4 28330 8.412120 5 5 28796 8.550491 6 6 28243 8.386286 7 7 29425 8.737262 8 8 29327 8.708162 9 9 27574 8.187638 10 10 28889 8.578105 11 11 27268 8.096776 12 12 28135 8.354218 Exercice 3.5 Calculer, pour chaque destination et chaque mois, le retard moyen à l’arrivée. Pour chaque mois, trier les destinations selon le retard décroissant, et ne conserver que les trois destinations avec le retard le plus important. # A tibble: 36 x 3 # Groups: month [12] month dest retard_moyen &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; 1 1 TUL 68.11538 2 1 OKC 57.69565 3 1 CAE 55.87500 4 2 DSM 48.18182 5 2 TUL 33.54545 6 2 GSP 32.93478 7 3 DSM 60.57692 8 3 CAE 46.88889 9 3 PVD 44.29787 10 4 CAE 71.33333 # ... with 26 more rows 9.8.4 Jointures Exercice 5.1 Faire la jointure de la table airline sur la table flights à l’aide de left_join. Joining, by = &quot;carrier&quot; # A tibble: 336,776 x 22 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 6 15 1432 1935 1137 1607 3 2013 1 10 1121 1635 1126 1239 4 2013 9 20 1139 1845 1014 1457 5 2013 7 22 845 1600 1005 1044 6 2013 4 10 1100 1900 960 1342 7 2013 3 17 2321 810 911 135 8 2013 6 27 959 1900 899 1236 9 2013 7 22 2257 759 898 121 10 2013 12 5 756 1700 896 1058 # ... with 336,766 more rows, and 15 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;, # name &lt;chr&gt; Exercice 5.2 À partir de la table résultat de l’exercice précédent, calculer le retard moyen au départ pour chaque compagnie, trier selon ce retard décroissant et afficher le nom de la compagnie et le retard correspondant. Joining, by = &quot;carrier&quot; # A tibble: 16 x 2 name retard_moyen &lt;chr&gt; &lt;dbl&gt; 1 Frontier Airlines Inc. 20.215543 2 ExpressJet Airlines Inc. 19.955390 3 Mesa Airlines Inc. 18.996330 4 AirTran Airways Corporation 18.726075 5 Southwest Airlines Co. 17.711744 6 Endeavor Air Inc. 16.725769 7 JetBlue Airways 13.022522 8 Virgin America 12.869421 9 SkyWest Airlines Inc. 12.586207 10 United Air Lines Inc. 12.106073 11 Envoy Air 10.552041 12 Delta Air Lines Inc. 9.264505 13 American Airlines Inc. 8.586016 14 Alaska Airlines Inc. 5.804775 15 Hawaiian Airlines Inc. 4.900585 16 US Airways Inc. 3.782418 Exercice 5.3 Faire la jointe de la table airports sur la table flights en utilisant comme clé le code de l’aéroport de destination. # A tibble: 336,776 x 29 year month day dep_time sched_dep_time dep_delay arr_time &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; 1 2013 1 9 641 900 1301 1242 2 2013 6 15 1432 1935 1137 1607 3 2013 1 10 1121 1635 1126 1239 4 2013 9 20 1139 1845 1014 1457 5 2013 7 22 845 1600 1005 1044 6 2013 4 10 1100 1900 960 1342 7 2013 3 17 2321 810 911 135 8 2013 6 27 959 1900 899 1236 9 2013 7 22 2257 759 898 121 10 2013 12 5 756 1700 896 1058 # ... with 336,766 more rows, and 22 more variables: sched_arr_time &lt;int&gt;, # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;, vitesse &lt;dbl&gt;, # name &lt;chr&gt;, lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;int&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, # tzone &lt;chr&gt;, alt_m &lt;dbl&gt; À partir de cette table, afficher pour chaque mois le nom de l’aéroport de destination ayant eu le plus petit nombre de vol. # A tibble: 14 x 3 # Groups: month [12] month name n &lt;int&gt; &lt;chr&gt; &lt;int&gt; 1 1 Key West Intl 1 2 2 Jackson Hole Airport 3 3 3 Bangor Intl 2 4 4 Key West Intl 1 5 4 Myrtle Beach Intl 1 6 5 Columbia Metropolitan 9 7 6 Myrtle Beach Intl 1 8 7 La Guardia 1 9 8 South Bend Rgnl 1 10 9 South Bend Rgnl 5 11 10 Albany Intl 1 12 10 South Bend Rgnl 1 13 11 Blue Grass 1 14 12 South Bend Rgnl 1 Exercice 5.4 Créer une table indiquant, pour chaque trajet, le nom de l’aéroport de départ et celui de l’aéroport d’arrivée. flights %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) %&gt;% rename(dest_name = name) %&gt;% left_join(airports, by = c(&quot;origin&quot; = &quot;faa&quot;)) %&gt;% rename(orig_name = name) %&gt;% select(orig_name, dest_name) # A tibble: 336,776 x 2 orig_name dest_name &lt;chr&gt; &lt;chr&gt; 1 John F Kennedy Intl Honolulu Intl 2 John F Kennedy Intl Port Columbus Intl 3 Newark Liberty Intl Chicago Ohare Intl 4 John F Kennedy Intl San Francisco Intl 5 John F Kennedy Intl Cincinnati Northern Kentucky Intl 6 John F Kennedy Intl Tampa Intl 7 La Guardia Minneapolis St Paul Intl 8 John F Kennedy Intl Portland Intl 9 La Guardia Hartsfield Jackson Atlanta Intl 10 Newark Liberty Intl Miami Intl # ... with 336,766 more rows 9.8.5 Bonus Exercice 6.1 Calculer le nombre de vols selon l’aéroport de destination, et fusionnez la table airports sur le résultat avec left_join. Stocker le résultat final dans un objet nommé flights_dest. # A tibble: 105 x 10 dest n name lat lon alt &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; 1 ABQ 254 Albuquerque International Sunport 35.04022 -106.60919 5355 2 ACK 265 Nantucket Mem 41.25305 -70.06018 48 3 ALB 439 Albany Intl 42.74827 -73.80169 285 4 ANC 8 Ted Stevens Anchorage Intl 61.17436 -149.99636 152 5 ATL 17215 Hartsfield Jackson Atlanta Intl 33.63672 -84.42807 1026 6 AUS 2439 Austin Bergstrom Intl 30.19453 -97.66989 542 7 AVL 275 Asheville Regional Airport 35.43619 -82.54181 2165 8 BDL 443 Bradley Intl 41.93889 -72.68322 173 9 BGR 375 Bangor Intl 44.80744 -68.82814 192 10 BHM 297 Birmingham Intl 33.56294 -86.75355 644 # ... with 95 more rows, and 4 more variables: tz &lt;dbl&gt;, dst &lt;chr&gt;, # tzone &lt;chr&gt;, alt_m &lt;dbl&gt; Créez une carte interactive des résultats avec leaflet et le code suivant : library(leaflet) leaflet(data = flights_dest) %&gt;% addTiles %&gt;% addCircles(lng=~lon, lat=~lat, radius=~n * 10, popup=~name) Créez une carte statique des résultats avec ggmap et le code suivant : library(ggmap) map &lt;- get_map(location = &quot;Kansas&quot;, zoom=4, color=&quot;bw&quot;) ggmap(map, extent = &quot;device&quot;) + geom_point(data = flights_dest, aes(x=lon, y=lat, size=n), color = &quot;red&quot;, alpha = 0.2) Pour plus d’informations sur les tests et leur syntaxe, voir la section 10.2↩ Le pipe a été introduit à l’origine par l’extension magrittr, et repris par dplyr↩ "],
["10-recodages.html", "Partie 10 Recoder et calculer des variables 10.1 Rappel sur les variables et les vecteurs 10.2 Tests et comparaison 10.3 Recoder une variable qualitative 10.4 Combiner une ou plusieurs variables 10.5 Découper une variable numérique en classes 10.6 Exercices", " Partie 10 Recoder et calculer des variables 10.1 Rappel sur les variables et les vecteurs Dans R, une variable, en général une colonne d’un tableau de données, est un objet de type vecteur. Un vecteur est un ensemble d’éléments, tous du même type. On a vu qu’on peut construire un vecteur manuellement de différentes manières : couleur &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) nombres &lt;- 1:10 Mais le plus souvent on manipule des vecteurs faisant partie d’une table importée dans R. Dans ce qui suit on va utiliser le jeu de données d’exemple hdv2003 de l’extension questionr. library(questionr) data(hdv2003) Quand on veut accéder à un vecteur d’un tableau de données, on peut utiliser l’opérateur $ : hdv2003$qualif Quand on utilise dplyr, on a vu qu’on peut utiliser select14 : hdv2003 %&gt;% select(qualif) On peut facilement créer de nouvelles variables (ou colonnes) dans un tableau de données en utilisant le $ : hdv2003$minutes.tv &lt;- hdv2003$heures.tv * 60 Ou à l’aide de la fonction mutate de dplyr : hdv2003 &lt;- hdv2003 %&gt;% mutate(minutes.tv = heures.tv * 60) Les vecteurs peuvent être de classes différentes, selon le type de données qu’ils contiennent. On a ainsi des vecteurs de classe numeric ou integer, qui contiennent des nombres : class(hdv2003$heures.tv) [1] &quot;numeric&quot; Des vecteurs de classe character, qui contiennent des chaînes de caractères : vec &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) class(vec) [1] &quot;character&quot; Et des vecteurs de classe logical, qui ne peuvent contenir que les valeurs vraie (TRUE) ou fausse (FALSE). vec &lt;- c(TRUE, FALSE, FALSE, TRUE) class(vec) [1] &quot;logical&quot; On peut convertir un vecteur d’une classe en une autre en utilisant les fonctions as.numeric, as.character ou as.logical. Les valeurs qui n’ont pas pu être converties sont automatiquement transformées en NA. x &lt;- c(&quot;1&quot;, &quot;2.35&quot;, &quot;8.2e+03&quot;, &quot;foo&quot;) as.numeric(x) Warning: NAs introduits lors de la conversion automatique [1] 1.00 2.35 8200.00 NA y &lt;- 2:6 as.character(y) [1] &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; On peut sélectionner certains éléments d’un vecteur à l’aide de l’opérateur []. La manière la plus simple est d’indiquer la position des éléments qu’on veut sélectionner : vec &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) vec[c(1,3)] [1] &quot;Jaune&quot; &quot;Rouge&quot; 10.2 Tests et comparaison Un test est une opération logique de comparaison qui renvoit vrai (TRUE) ou faux (FALSE) pour chacun des éléments d’un vecteur. Parmi les opérateurs tests disponibles, on trouve notamment : == qui teste l’égalité != qui teste la différence &gt;, &lt;, &lt;=, &gt;= qui testent la supériorité ou l’infériorité. %in% qui teste l’appartenance à un ensemble de valeurs Exemple le plus simple : 2 == 3 [1] FALSE Exemple appliqué à un vecteur : x &lt;- 1:10 x [1] 1 2 3 4 5 6 7 8 9 10 x &lt; 5 [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE On peut combiner plusieurs tests avec les opérateurs logiques et (&amp;) et ou (|). Ainsi, si on veut tester qu’une valeur est comprise entre 3 et 6, on peut faire : x &gt;= 3 &amp; x &lt;= 6 [1] FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE Si on veut tester qu’une valeur est égale à “Bleu” ou à “Vert”, on peut faire : vec &lt;- c(&quot;Jaune&quot;, &quot;Jaune&quot;, &quot;Rouge&quot;, &quot;Vert&quot;) vec == &quot;Jaune&quot; | vec == &quot;Vert&quot; [1] TRUE TRUE FALSE TRUE À noter que dans ce cas, on peut utiliser l’opérateur %in%, qui teste si une valeur fait partie des éléments d’un vecteur : vec %in% c(&quot;Jaune&quot;, &quot;Vert&quot;) [1] TRUE TRUE FALSE TRUE Enfin, on peut inverser un test avec l’opérateur non (!) : !(vec %in% c(&quot;Jaune&quot;, &quot;Vert&quot;)) [1] FALSE FALSE TRUE FALSE Les tests sont notamment utilisés par le verbe filter de dplyr (voir section 9.2.2) qui permet de sélectionner certaines lignes d’un tableau de données : hdv2003 %&gt;% filter(age &gt;= 20 &amp; age &lt;= 40) # A tibble: 684 x 21 id age sexe nivetud &lt;int&gt; &lt;int&gt; &lt;fctr&gt; &lt;fctr&gt; 1 1 28 Femme Enseignement superieur y compris technique superieur 2 2 23 Femme NA 3 4 34 Homme Enseignement superieur y compris technique superieur 4 6 35 Femme Enseignement technique ou professionnel court 5 9 20 Femme NA 6 10 28 Homme Enseignement technique ou professionnel long 7 18 20 Femme NA 8 20 39 Femme Enseignement technique ou professionnel court 9 21 30 Femme Enseignement technique ou professionnel court 10 22 30 Homme Enseignement technique ou professionnel court # ... with 674 more rows, and 17 more variables: poids &lt;dbl&gt;, # occup &lt;fctr&gt;, qualif &lt;fctr&gt;, freres.soeurs &lt;int&gt;, clso &lt;fctr&gt;, # relig &lt;fctr&gt;, trav.imp &lt;fctr&gt;, trav.satisf &lt;fctr&gt;, hard.rock &lt;fctr&gt;, # lecture.bd &lt;fctr&gt;, peche.chasse &lt;fctr&gt;, cuisine &lt;fctr&gt;, bricol &lt;fctr&gt;, # cinema &lt;fctr&gt;, sport &lt;fctr&gt;, heures.tv &lt;dbl&gt;, minutes.tv &lt;dbl&gt; hdv2003 %&gt;% filter(qualif %in% c(&quot;Ouvrier specialise&quot;, &quot;Ouvrier qualifie&quot;)) # A tibble: 495 x 21 id age sexe nivetud &lt;int&gt; &lt;int&gt; &lt;fctr&gt; &lt;fctr&gt; 1 7 60 Femme Derniere annee d&#39;etudes primaires 2 8 47 Homme Enseignement technique ou professionnel court 3 12 47 Homme 2eme cycle 4 19 70 Homme Derniere annee d&#39;etudes primaires 5 20 39 Femme Enseignement technique ou professionnel court 6 25 20 Femme NA 7 27 31 Femme Enseignement technique ou professionnel long 8 28 35 Homme 1er cycle 9 29 35 Homme Enseignement technique ou professionnel court 10 30 30 Homme Enseignement technique ou professionnel court # ... with 485 more rows, and 17 more variables: poids &lt;dbl&gt;, # occup &lt;fctr&gt;, qualif &lt;fctr&gt;, freres.soeurs &lt;int&gt;, clso &lt;fctr&gt;, # relig &lt;fctr&gt;, trav.imp &lt;fctr&gt;, trav.satisf &lt;fctr&gt;, hard.rock &lt;fctr&gt;, # lecture.bd &lt;fctr&gt;, peche.chasse &lt;fctr&gt;, cuisine &lt;fctr&gt;, bricol &lt;fctr&gt;, # cinema &lt;fctr&gt;, sport &lt;fctr&gt;, heures.tv &lt;dbl&gt;, minutes.tv &lt;dbl&gt; On peut utiliser les tests pour sélectionner certains éléments d’un vecteur : si on passeun test à l’opérateur de sélection [], seuls les éléments pour lesquels ce test est vrai seront conservés : x &lt;- c(12, 8, 14, 7, 6, 18) x[x &gt; 10] [1] 12 14 18 10.3 Recoder une variable qualitative Pour rappel, on appelle variable qualitative une variable pouvant prendre un nombre limité de modalités (de valeurs possibles). 10.3.1 L’extension forcats Dans R, les variables qualitatives peuvent être de deux types : ou bien des vecteurs de type character (des chaînes de caractères), ou bien des factor (facteurs). Si vous utilisez les fonctions des extensions du tidyverse comme readr, readxl ou haven pour importer vos données, vos variables qualitatives seront importées sous forme de character. Mais dans les autres cas elles se retrouveront souvent sous forme de factor. C’est le cas dans notre jeu de données d’exemple : class(hdv2003$qualif) [1] &quot;factor&quot; forcats est une extension facilitant la manipulation des variables qualitatives, qu’elles soient sous forme de vecteurs character ou de facteurs. Elle ne fait pas à proprement parler partie du tidyverse, il faut donc la charger explicitement avec : library(forcats) 10.3.2 Modifier les modalités d’une variable qualitative Une opération courante consiste à modifier les valeurs d’une variable qualitative, que ce soit pour avoir des intitulés plus courts ou plus clairs ou pour regrouper des modalités entre elles. Il existe plusieurs possibilités pour effectuer ce type de recodage, mais ici on va utiliser la fonction fct_recode de l’extension forcats. Celle-ci prend en argument une liste de recodages sous la forme &quot;Nouvelle valeur&quot; = &quot;Ancienne valeur&quot;. Un exemple : f &lt;- c(&quot;Pomme&quot;, &quot;Poire&quot;, &quot;Pomme&quot;, &quot;Cerise&quot;) f &lt;- fct_recode(f, &quot;Fraise&quot; = &quot;Pomme&quot;, &quot;Ananas&quot; = &quot;Poire&quot;) f [1] Fraise Ananas Fraise Cerise Levels: Cerise Ananas Fraise Autre exemple sur une “vraie” variable : freq(hdv2003$qualif) # A tibble: 8 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 203 10.2 12.3 2 292 14.6 17.7 3 86 4.3 5.2 4 160 8.0 9.7 5 260 13.0 15.7 6 594 29.7 35.9 7 58 2.9 3.5 8 347 17.3 NA hdv2003 &lt;- hdv2003 %&gt;% mutate(qualif5 = fct_recode(qualif, &quot;Ouvrier&quot; = &quot;Ouvrier specialise&quot;, &quot;Ouvrier&quot; = &quot;Ouvrier qualifie&quot;, &quot;Interm&quot; = &quot;Technicien&quot;, &quot;Interm&quot; = &quot;Profession intermediaire&quot;)) freq(hdv2003$qualif5) # A tibble: 6 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 495 24.8 29.9 2 246 12.3 14.9 3 260 13.0 15.7 4 594 29.7 35.9 5 58 2.9 3.5 6 347 17.3 NA Attention, les anciennes valeurs saisies doivent être exactement égales aux valeurs des modalités du facteur : toute différence d’accent ou d’espaces fera que ce recodage ne sera pas pris en compte. Dans ce cas, forcats affiche un avertissement nous indiquant qu’une valeur saisie n’a pas été trouvée dans les modalités de la variable : hdv2003 &lt;- hdv2003 %&gt;% mutate(qualif_test = fct_recode(qualif, &quot;Ouvrier&quot; = &quot;Ouvrier spécialisé&quot;, &quot;Ouvrier&quot; = &quot;Ouvrier qualifié&quot;)) Warning: Unknown levels in `f`: Ouvrier spécialisé, Ouvrier qualifié D’autres fonctions sont proposées par forcats pour faciliter ces recodage, dont fct_collapse, qui propose une autre syntaxe pratique quand on doit regrouper ensemble des modalités : hdv2003 &lt;- hdv2003 %&gt;% mutate(qualif_rec = fct_collapse(qualif, &quot;Ouvrier&quot; = c(&quot;Ouvrier specialise&quot;, &quot;Ouvrier qualifie&quot;), &quot;Interm&quot; = c(&quot;Technicien&quot;, &quot;Profession intermediaire&quot;))) freq(hdv2003$qualif_rec) # A tibble: 6 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 495 24.8 29.9 2 246 12.3 14.9 3 260 13.0 15.7 4 594 29.7 35.9 5 58 2.9 3.5 6 347 17.3 NA fct_other, qui regroupe une liste de modalités en une seule modalité “Other” : hdv2003 &lt;- hdv2003 %&gt;% mutate(qualif_rec = fct_other(qualif, drop = c(&quot;Ouvrier specialise&quot;, &quot;Ouvrier qualifie&quot;, &quot;Cadre&quot;, &quot;Autre&quot;))) freq(hdv2003$qualif_rec) # A tibble: 5 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 86 4.3 5.2 2 160 8.0 9.7 3 594 29.7 35.9 4 813 40.6 49.2 5 347 17.3 NA fct_lump, qui regroupe automatiquement les modalités les moins fréquentes en une seule modalité “Other” (avec possibilité d’indiquer des seuils de regroupement) : hdv2003 &lt;- hdv2003 %&gt;% mutate(qualif_rec = fct_lump(qualif)) freq(hdv2003$qualif_rec) # A tibble: 7 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 203 10.2 12.3 2 292 14.6 17.7 3 160 8.0 9.7 4 260 13.0 15.7 5 594 29.7 35.9 6 144 7.2 8.7 7 347 17.3 NA fct_explicit_na qui convertit toutes les valeurs manquantes (NA) d’un facteur en une modalité spécifique : hdv2003 &lt;- hdv2003 %&gt;% mutate(qualif_rec = fct_explicit_na(qualif, na_level = &quot;(Manquant)&quot;)) freq(hdv2003$qualif_rec) # A tibble: 8 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 203 10.2 10.2 2 292 14.6 14.6 3 86 4.3 4.3 4 160 8.0 8.0 5 260 13.0 13.0 6 594 29.7 29.7 7 58 2.9 2.9 8 347 17.3 17.3 10.3.2.1 Interface graphique de recodage L’extension questionr propose une interface graphique facilitant le recodage des valeurs d’une variable qualitative. L’objectif est de permettre à l’utilisateur de saisir les nouvelles valeurs dans un formulaire, et de générer ensuite le code R correspondant au recodage indiqué. Pour utiliser cette interface, sous RStudio vous pouvez aller dans le menu Addins puis choisir Levels recoding. Sinon, vous pouvez lancer dans la console la fonction irec() en lui passant comme paramètre la variable à recoder. Interface graphique de irec L’interface se compose de trois onglets : l’onglet Variable et paramètres vous permet de sélectionner la variable à recoder, le nom de la nouvelle variable et d’autres paramètres, l’onglet Recodages vous permet de saisir les nouvelles valeurs des modalités, et l’onglet Code et résultat affiche le code R correspondant ainsi qu’un tableau permettant de vérifier les résultats. Une fois votre recodage terminé, cliquez sur le bouton Done et le code R sera inséré dans votre script R ou affiché dans la console. Attention, cette interface est prévue pour ne pas modifier vos données. C’est donc à vous d’exécuter le code généré pour que le recodage soit réellement effectif. 10.3.3 Ordonner les modalités d’une variable qualitative L’avantage des facteurs (par rapport aux vecteurs de type character) est que leurs modalités peuvent être ordonnées, ce qui peut faciliter la lecture de tableaux ou graphiques. On peut ordonner les modalités d’un facteur manuellement, par exemple avec la fonction fct_relevel() de l’extension forcats : hdv2003 &lt;- hdv2003 %&gt;% mutate(qualif_rec = fct_relevel(qualif, &quot;Cadre&quot;, &quot;Profession intermediaire&quot;, &quot;Technicien&quot;, &quot;Employe&quot;, &quot;Ouvrier qualifie&quot;, &quot;Ouvrier specialise&quot;, &quot;Autre&quot;)) freq(hdv2003$qualif_rec) # A tibble: 8 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 260 13.0 15.7 2 160 8.0 9.7 3 86 4.3 5.2 4 594 29.7 35.9 5 292 14.6 17.7 6 203 10.2 12.3 7 58 2.9 3.5 8 347 17.3 NA Une autre possibilité est d’ordonner les modalités d’un facteur selon les valeurs d’une autre variable. Par exemple, si on représente le boxplot de la répartition de l’âge selon le statut d’occupation : library(ggplot2) ggplot(hdv2003) + geom_boxplot(aes(x=occup, y=age)) Le graphique pourrait être plus lisible si les modalités étaient triées par âge median croissant. Ceci est possible en utilisant fct_reorder. Celle-ci prend 3 arguments : le facteur à réordonner, la variable dont les valeurs doivent être utilisées pour ce réordonnancement, et enfin une fonction à appliquer à cette deuxième variable. hdv2003 &lt;- hdv2003 %&gt;% mutate(occup_age = fct_reorder(occup, age, median)) ggplot(hdv2003) + geom_boxplot(aes(x = occup_age, y = age)) 10.3.3.1 Interface graphique On peut aussi utiliser l’interface graphique proposée par l’extension questionr afin de faciliter cette opération. Pour la lancer, sélectionner le menu Addins puis Levels ordering, ou exécuter la fonction iorder() en lui passant comme paramètre le facteur à réordonner. Interface graphique de iorder Le fonctionnement de l’interface est similaire à celui de l’interface de recodage. Vous pouvez réordonner les modalités en les faisant glisser avec la souris, puis récupérer et exécuter le code R généré. 10.4 Combiner une ou plusieurs variables Parfois, on veut créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions if_else pour les cas les plus simples, ou case_when pour les cas plus complexes. 10.4.1 if_else if_else prend trois arguments : un test, une valeur à renvoyer si le test est vrai, et une valeur à renvoyer si le test est faux. Voici un exemple simple : v &lt;- c(12, 14, 8, 16) if_else(v &gt; 10, &quot;Supérieur à 10&quot;, &quot;Inférieur à 10&quot;) [1] &quot;Supérieur à 10&quot; &quot;Supérieur à 10&quot; &quot;Inférieur à 10&quot; &quot;Supérieur à 10&quot; La fonction devient plus intéressante avec des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans : hdv2003 &lt;- hdv2003 %&gt;% mutate(statut = if_else(sexe == &quot;Homme&quot; &amp; age &gt; 60, &quot;Homme de plus de 60 ans&quot;, &quot;Autre&quot;)) freq(hdv2003$statut) # A tibble: 2 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1778 88.9 88.9 2 222 11.1 11.1 10.4.2 case_when case_when est une génération du if_else qui permet d’indiquer plusieurs tests et leurs valeurs associées. Imaginons qu’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante : hdv2003 &lt;- hdv2003 %&gt;% mutate(statut = case_when( age &gt; 60 &amp; sexe == &quot;Homme&quot; ~ &quot;Homme de plus de 60 ans&quot;, age &gt; 60 &amp; sexe == &quot;Femme&quot; ~ &quot;Femme de plus de 60 ans&quot;, TRUE ~ &quot;Autre&quot;)) freq(hdv2003$statut) # A tibble: 3 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1512 75.6 75.6 2 266 13.3 13.3 3 222 11.1 11.1 case_when prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoit la valeur associée. La clause TRUE ~ &quot;Autre&quot; permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie. Attention : comme les conditions sont testées l’une après l’autre et que la valeur renvoyée est celle correspondant à la première condition vraie, l’ordre de ces conditions est très important. Il faut absolument aller du plus spécifique au plus général. Par exemple le recodage suivant ne fonctionne pas : hdv2003 &lt;- hdv2003 %&gt;% mutate(statut = case_when( sexe == &quot;Homme&quot; ~ &quot;Homme&quot;, sexe == &quot;Homme&quot; &amp; age &gt; 60 ~ &quot;Homme de plus de 60 ans&quot;, TRUE ~ &quot;Autre&quot;)) freq(hdv2003$statut) # A tibble: 2 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1101 55 55 2 899 45 45 Comme la condition sexe == &quot;Homme&quot; est plus générale que sexe == &quot;Homme&quot; &amp; age &gt; 60, cette deuxième condition n’est jamais testée ! On n’obtiendra jamais la valeur correspondante. Pour que ce recodage fonctionne il faut donc changer l’ordre des conditions pour aller du plus spécifique au plus général : hdv2003 &lt;- hdv2003 %&gt;% mutate(statut = case_when( sexe == &quot;Homme&quot; &amp; age &gt; 60 ~ &quot;Homme de plus de 60 ans&quot;, sexe == &quot;Homme&quot; ~ &quot;Homme&quot;, TRUE ~ &quot;Autre&quot;)) freq(hdv2003$statut) # A tibble: 3 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1101 55.0 55.0 2 677 33.9 33.9 3 222 11.1 11.1 10.5 Découper une variable numérique en classes Une opération relativement courante consiste à découper une variable numérique en classes. Par exemple, on voudra transformer une variable revenu contenant le revenu mensuel en une variable avec des catégorie Moins de 500 euros, 500-1000 euros, etc. Pour cela on peut utiliser la fonction cut() : hdv2003$agecl &lt;- cut(hdv2003$age, breaks = 5) freq(hdv2003$agecl) # A tibble: 5 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 454 22.7 22.7 2 628 31.4 31.4 3 556 27.8 27.8 4 319 16.0 16.0 5 43 2.1 2.1 Si on donne un nombre entier à l’argument breaks, un nombre correspondant de classes d’amplitudes égales sont automatiquement calculées. Il est souvent préférable cependant d’avoir des limites “rondes”, on peut alors spécifier ces dernières manuellement en passant un vecteur à breaks : hdv2003$agecl &lt;- cut(hdv2003$age, breaks = c(18, 25, 35, 45, 55, 65, 97), include.lowest = TRUE) freq(hdv2003$agecl) # A tibble: 6 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 191 9.6 9.6 2 338 16.9 16.9 3 390 19.5 19.5 4 414 20.7 20.7 5 305 15.2 15.2 6 362 18.1 18.1 Ici on a été obligé d’ajouter l’argument include.lowest = TRUE car sinon la valeur 18 n’aurait pas été incluse, et on aurait eu des valeurs manquantes. 10.5.1 Interface graphique Comme l’utilisation des arguments de cut n’est pas toujours très intuitive, l’extension questionr propose une interface graphique facilitant cette opếration de découpage en classes d’une variable numérique. Pour lancer cette interface, sous RStudio ouvrir le menu Addins et sélectionner Variable cutting, ou exécuter la fonction icut() dans la console en lui passant comme argument la variable numériqueà découper. Interface graphique de icut Vous pouvez alors choisir la variable à découper dans l’onglet Variable et paramètres, indiquer les limites de vos classes ainsi que quelques options complémentaires dans l’onglet Découpage en classes, et vérifier le résultat dans l’onglet Code et résultat. Une fois le résultat satisfaisant, cliquez sur Done : si vous êtes sous RStudio le code généré sera directement inséré dans votre script actuel à l’emplacement du curseur. Sinon, ce code sera affiché dans la console et vous pourrez le copier/coller pour l’inclure dans votre script. Attention, cette interface est prévue pour ne pas modifier vos données. C’est donc à vous d’exécuter le code généré pour que le découpage soit réellement effectif. 10.6 Exercices 10.6.1 Préparation Pour ces exercices, on a besoin des extensions forcats et questionr, et du jeu de données d’exemple hdv2003. library(forcats) library(questionr) data(hdv2003) 10.6.2 Vecteurs et tests Exercice 1.1 Construire le vecteur suivant : x &lt;- c(&quot;12&quot;, &quot;3.5&quot;, &quot;421&quot;, &quot;2,4&quot;) Et le convertir en vecteur numérique. Que remarquez-vous ? Exercice 1.2 Construire le vecteur suivant : x &lt;- c(1, 20, 21, 15.5, 14, 12, 8, 16, 1) Écrire le test qui indique si les éléments du vecteur sont strictement supérieurs à 15. Utiliser ce test pour extraire du vecteur les éléments correspondants. Exercice 1.3 Le code suivant génère un vecteur de 1000 nombres aléatoires compris entre 0 et 10 : x &lt;- runif(1000, 0, 10) Combien d’éléments de ce vecteur sont compris entre 2 et 4 ? 10.6.3 Recodages de variable qualitative Exercice 2.1 Dans le jeu de données hdv2003, découper la variable heures.tv en classes de manière à obtenir au final le tri à plat suivant : # A tibble: 6 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 684 34.2 34.3 2 535 26.8 26.8 3 594 29.7 29.8 4 138 6.9 6.9 5 44 2.2 2.2 6 5 0.2 NA Exercice 2.2 Construire un vecteur f à l’aide du code suivant : f &lt;- c(&quot;Jan&quot;, &quot;Jan&quot;, &quot;Fev&quot;, &quot;Juil&quot;) Recoder le vecteur à l’aide de la fonction fct_recode pour obtenir le résultat suivant : [1] Janvier Janvier Février Juillet Levels: Février Janvier Juillet Exercice 2.3 À l’aide de l’interface graphique irec de questionr, recoder la variable relig du jeu de données hdv2003 pour obtenir le tri à plat suivant : # A tibble: 5 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 708 35.4 35.4 2 760 38.0 38.0 3 399 20.0 20.0 4 93 4.7 4.7 5 40 2.0 2.0 Exercice 2.4 À l’aide de l’interface graphique de questionr, recoder la variable nivetud pour obtenir le tri à plat suivant : # A tibble: 7 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 39 2.0 2.1 2 427 21.3 22.6 3 204 10.2 10.8 4 183 9.2 9.7 5 594 29.7 31.5 6 441 22.1 23.4 7 112 5.6 NA Toujours à l’aide de l’interface graphique, réordonner les modalités de cette variable recodée pour obtenir le tri à plat suivant : # A tibble: 7 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 441 22.1 23.4 2 594 29.7 31.5 3 183 9.2 9.7 4 204 10.2 10.8 5 427 21.3 22.6 6 39 2.0 2.1 7 112 5.6 NA Exercice 2.5 À l’aide de la fonction fct_reorder, trier les modalités de la variable relig du jeu de données hdv2003 selon leur âge médian. Vérifier en générant le boxplot suivant : 10.6.4 Combiner plusieurs variables Exercice 3.1 À l’aide de la fonction if_else, créer une nouvelle variable cinema_bd permettant d’identifier les personnes qui vont au cinéma et déclarent lire des bandes dessinées. Vous devriez obtenir le tri à plat suivant pour cette nouvelle variable : # A tibble: 2 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1971 98.6 98.6 2 29 1.5 1.5 Exercice 3.2 À l’aide de la fonction case_when, créer une nouvelle variable ayant les modalités suivantes : Homme ayant plus de 2 frères et soeurs Femme ayant plus de 2 frères et soeurs Autre Vous devriez obtenir le tri à plat suivant : # A tibble: 3 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1001 50.0 50.0 2 546 27.3 27.3 3 453 22.7 22.7 Exercice 3.3 À l’aide de la fonction case_when, créer une nouvelle variable ayant les modalités suivantes : Homme de plus de 30 ans Homme de plus de 40 ans satisfait par son travail Femme pratiquant le sport ou le bricolage Autre Vous devriez obtenir le tri à plat suivant : # A tibble: 4 x 3 n `%` `val%` * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 714 35.7 35.7 2 549 27.5 27.5 3 610 30.5 30.5 4 127 6.3 6.3 À la différence de $, select ne renvoie cependant pas un vecteur mais à un tableau à une seule colonne. Si on veut extraire le vecteur on peut utiliser la fonction pull : {r eval=FALSE} hdv2003 %&gt;% pull(qualif)↩ "],
["11-tidyr.html", "Partie 11 Arranger ses données 11.1 Tidy data 11.2 Trois règles pour des données bien rangées 11.3 Les verbes de tidyr 11.4 Ressources", " Partie 11 Arranger ses données 11.1 Tidy data Comme indiqué dans la section 6.3, les extensions du tidyverse comme dplyr ou ggplot2 partent du principe que les données sont “bien rangées” sous forme de tidy data. Prenons un exemple avec les données suivantes : # A tibble: 3 x 5 country `1992` `1997` `2002` `2007` * &lt;fctr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Belgium 10045622 10199787 10311970 10392226 2 France 57374179 58623428 59925035 61083916 3 Germany 80597764 82011073 82350671 82400996 Imaginons qu’on souhaite représenter avec ggplot2 l’évolution de la population pour chaque pays sous forme de lignes : c’est impossible avec les données sous ce format. On a besoin d’arranger le tableau de la manière suivante : # A tibble: 12 x 3 country annee population &lt;fctr&gt; &lt;dbl&gt; &lt;int&gt; 1 Belgium 1992 10045622 2 France 1992 57374179 3 Germany 1992 80597764 4 Belgium 1997 10199787 5 France 1997 58623428 6 Germany 1997 82011073 7 Belgium 2002 10311970 8 France 2002 59925035 9 Germany 2002 82350671 10 Belgium 2007 10392226 11 France 2007 61083916 12 Germany 2007 82400996 Il est alors possible de réaliser le graphique : ggplot(d) + geom_line(aes(x = annee, y = population, color = country)) + scale_x_continuous(breaks = unique(d$annee)) C’est la même chose pour dplyr, si on voulait calculer la population minimale pour chaque pays avec summarise : d %&gt;% group_by(country) %&gt;% summarise(pop_min = min(population)) # A tibble: 3 x 2 country pop_min &lt;fctr&gt; &lt;dbl&gt; 1 Belgium 10045622 2 France 57374179 3 Germany 80597764 11.2 Trois règles pour des données bien rangées Le concept de tidy data repose sur trois règles interdépendantes. Des données sont considérées comme tidy si : chaque ligne correspond à une observation chaque colonne correspond à une variable chaque valeur est présente dans une unique case de la table ou, de manière équivalente, si des unités d’observations différentes sont présentes dans des tables différentes Ces règles ne sont pas forcément très intuitives. De plus, il y a une infinité de manières pour un tableau de données de ne pas être tidy. Prenons par exemple les règles 1 et 2 et le tableau de notre premier exemple : dm # A tibble: 3 x 5 country `1992` `1997` `2002` `2007` * &lt;fctr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 Belgium 10045622 10199787 10311970 10392226 2 France 57374179 58623428 59925035 61083916 3 Germany 80597764 82011073 82350671 82400996 Pourquoi ce tableau n’est pas tidy ? Parce que si on essaie d’identifier les variables mesurées dans le tableau, il y en a trois : le pays, l’année et la population. Or elles ne correspondant pas aux colonnes de la table. C’est le cas par contre pour la table transformée : dm %&gt;% gather(annee, population, -country) # A tibble: 12 x 3 country annee population &lt;fctr&gt; &lt;chr&gt; &lt;int&gt; 1 Belgium 1992 10045622 2 France 1992 57374179 3 Germany 1992 80597764 4 Belgium 1997 10199787 5 France 1997 58623428 6 Germany 1997 82011073 7 Belgium 2002 10311970 8 France 2002 59925035 9 Germany 2002 82350671 10 Belgium 2007 10392226 11 France 2007 61083916 12 Germany 2007 82400996 Et on peut remarquer qu’en modifiant notre table pour satisfaire à la deuxième règle, on a aussi réglé la première : chaque ligne correspond désormais à une observation, qui est en l’occurrence l’observation de pays à plusieurs moments dans le temps. Dans notre table d’origine, chaque ligne comportait en réalité quatre observations différentes. Cela permet aussi d’illustrer que les règles sont interdépendantes. Un autre exemple, tiré du jeu de données nycflights13, permettant cette fois d’illustrer la troisième règle : # A tibble: 8 x 6 year month day dep_time carrier name &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 2013 1 1 517 UA United Air Lines Inc. 2 2013 1 1 533 UA United Air Lines Inc. 3 2013 1 1 542 AA American Airlines Inc. 4 2013 1 1 554 UA United Air Lines Inc. 5 2013 1 1 558 AA American Airlines Inc. 6 2013 1 1 558 UA United Air Lines Inc. 7 2013 1 1 558 UA United Air Lines Inc. 8 2013 1 1 559 AA American Airlines Inc. Dans ce tableau on a bien une observation par ligne (un vol), et une variable par colonne. Mais on a une “infraction” à la troisième règle, qui est que chaque valeur doit être présente dans une unique case de la table avec la colonne name. On a en effet une duplication de l’information concernant le nom des compagnies aériennes. Notre tableau mêle en fait deux types d’observations différents : des observations sur les vols, et des observations sur les compagnies aériennes. Pour “arranger” ce tableau, il faut séparer les deux types d’observations en deux tables différentes : # A tibble: 8 x 5 year month day dep_time carrier &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 1 2013 1 1 517 UA 2 2013 1 1 533 UA 3 2013 1 1 542 AA 4 2013 1 1 554 UA 5 2013 1 1 558 AA 6 2013 1 1 558 UA 7 2013 1 1 558 UA 8 2013 1 1 559 AA # A tibble: 2 x 2 carrier name &lt;chr&gt; &lt;chr&gt; 1 UA United Air Lines Inc. 2 AA American Airlines Inc. On a désormais deux tables distinctes, l’information n’est pas dupliquée, et on peut facilement faire une jointure si on a besoin de récupérer l’information d’une table dans une autre. 11.3 Les verbes de tidyr L’objectif de tidyr est de fournir des fonctions pour arranger ses données et les convertir dans un format tidy. Ces fonctions prennent la forme de verbes qui viennent compléter ceux de dplyr et s’intègrent parfaitement dans les séries de pipes (%&gt;%) permettant d’enchaîner les opérations. 11.3.1 gather : rassembler des colonnes Prenons le tableau d suivant, qui liste la population de 6 pays en 2002 et 2007 : library(gapminder) data(gapminder) d &lt;- gapminder d &lt;- d %&gt;% filter(country %in% c(&quot;France&quot;, &quot;Germany&quot;, &quot;Belgium&quot;, &quot;Switzerland&quot;, &quot;Spain&quot;, &quot;Italy&quot;), year &gt;= 2002) %&gt;% select(country, year, pop) %&gt;% spread(year, pop) d # A tibble: 6 x 3 country `2002` `2007` * &lt;fctr&gt; &lt;int&gt; &lt;int&gt; 1 Belgium 10311970 10392226 2 France 59925035 61083916 3 Germany 82350671 82400996 4 Italy 57926999 58147733 5 Spain 40152517 40448191 6 Switzerland 7361757 7554661 Dans ce tableau, une même variable (la population) est répartie sur plusieurs colonnes, chacune représentant une observation à un moment différent. On souhaite que la variable ne représente plus qu’une seule colonne, et que les observations soient réparties sur plusieurs lignes. Pour cela on va utiliser la fonction gather (rassembler) : d %&gt;% gather(`2002`, `2007`, key = annee, value = population) # A tibble: 12 x 3 country annee population &lt;fctr&gt; &lt;chr&gt; &lt;int&gt; 1 Belgium 2002 10311970 2 France 2002 59925035 3 Germany 2002 82350671 4 Italy 2002 57926999 5 Spain 2002 40152517 6 Switzerland 2002 7361757 7 Belgium 2007 10392226 8 France 2007 61083916 9 Germany 2007 82400996 10 Italy 2007 58147733 11 Spain 2007 40448191 12 Switzerland 2007 7554661 La fonction gather prend comme arguments la liste des colonnes à rassembler (ici on a mis 2002 et 2007 entre backticks (2002) pour indiquer à gather qu’il s’agit d’un nom de colonne et pas d’un nombre), ainsi que deux arguments key et value : key est le nom de la colonne qui va contenir les “clés”, c’est-à-dire les identifiants des différentes observations value est le nom de la colonne qui va contenir la valeur des observations Parfois il est plus rapide d’indiquer à gather les colonnes qu’on ne souhaite pas rassembler. On peut le faire avec la syntaxe suivante : d %&gt;% gather(-country, key = annee, value = population) # A tibble: 12 x 3 country annee population &lt;fctr&gt; &lt;chr&gt; &lt;int&gt; 1 Belgium 2002 10311970 2 France 2002 59925035 3 Germany 2002 82350671 4 Italy 2002 57926999 5 Spain 2002 40152517 6 Switzerland 2002 7361757 7 Belgium 2007 10392226 8 France 2007 61083916 9 Germany 2007 82400996 10 Italy 2007 58147733 11 Spain 2007 40448191 12 Switzerland 2007 7554661 11.3.2 spread : disperser des lignes La fonction spread est l’inverse de gather. Soit le tableau d suivant : library(gapminder) data(gapminder) dm &lt;- gapminder dm &lt;- dm %&gt;% filter(country %in% c(&quot;France&quot;, &quot;Germany&quot;, &quot;Belgium&quot;), year &gt;= 2002) %&gt;% select(-gdpPercap) %&gt;% gather(lifeExp, pop, key = variable, value = value) dm # A tibble: 12 x 5 country continent year variable value &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; 1 Belgium Europe 2002 lifeExp 78.320 2 Belgium Europe 2007 lifeExp 79.441 3 France Europe 2002 lifeExp 79.590 4 France Europe 2007 lifeExp 80.657 5 Germany Europe 2002 lifeExp 78.670 6 Germany Europe 2007 lifeExp 79.406 7 Belgium Europe 2002 pop 10311970.000 8 Belgium Europe 2007 pop 10392226.000 9 France Europe 2002 pop 59925035.000 10 France Europe 2007 pop 61083916.000 11 Germany Europe 2002 pop 82350671.000 12 Germany Europe 2007 pop 82400996.000 Ce tableau a le problème inverse du précédent : on a deux variables, lifeExp et pop qui, plutôt que d’être réparties en deux colonnes, sont réparties entre plusieurs lignes. On va donc utiliser spread pour “disperser” ces lignes dans deux colonnes différentes : dm %&gt;% spread(key = variable, value = value) # A tibble: 6 x 5 country continent year lifeExp pop * &lt;fctr&gt; &lt;fctr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Belgium Europe 2002 78.320 10311970 2 Belgium Europe 2007 79.441 10392226 3 France Europe 2002 79.590 59925035 4 France Europe 2007 80.657 61083916 5 Germany Europe 2002 78.670 82350671 6 Germany Europe 2007 79.406 82400996 spread prend deux arguments principaux : key indique la colonne contenant les noms des nouvelles variables à créer value indique la colonne contenant les valeurs de ces variables Il peut arriver que certaines variables soient absentes pour certaines observations. Dans ce cas l’argument fill permet de spécifier la valeur à utiliser pour ces données manquantes (par défaut fill vaut, logiquement, NA) : # A tibble: 13 x 5 country continent year variable value &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 Belgium Europe 2002 lifeExp 78.320 2 Belgium Europe 2007 lifeExp 79.441 3 France Europe 2002 lifeExp 79.590 4 France Europe 2007 lifeExp 80.657 5 Germany Europe 2002 lifeExp 78.670 6 Germany Europe 2007 lifeExp 79.406 7 Belgium Europe 2002 pop 10311970.000 8 Belgium Europe 2007 pop 10392226.000 9 France Europe 2002 pop 59925035.000 10 France Europe 2007 pop 61083916.000 11 Germany Europe 2002 pop 82350671.000 12 Germany Europe 2007 pop 82400996.000 13 France Europe 2002 density 94.000 dm %&gt;% spread(key = variable, value = value, fill = &quot;-&quot;) # A tibble: 6 x 6 country continent year density lifeExp pop * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Belgium Europe 2002 - 78.32 10311970 2 Belgium Europe 2007 - 79.441 10392226 3 France Europe 2002 94 79.59 59925035 4 France Europe 2007 - 80.657 61083916 5 Germany Europe 2002 - 78.67 82350671 6 Germany Europe 2007 - 79.406 82400996 11.3.3 separate : séparer une colonne en plusieurs Parfois on a plusieurs informations réunies en une seule colonne et on souhaite les séparer. Soit le tableau d’exemple caricatural suivant, nommé df : # A tibble: 3 x 2 eleve note &lt;chr&gt; &lt;chr&gt; 1 Félicien Machin 5/20 2 Raymonde Bidule 6/10 3 Martial Truc 87/100 separate permet de séprer la colonne note en deux nouvelles colonnes note et note_sur : df %&gt;% separate(note, c(&quot;note&quot;, &quot;note_sur&quot;)) # A tibble: 3 x 3 eleve note note_sur * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Félicien Machin 5 20 2 Raymonde Bidule 6 10 3 Martial Truc 87 100 separate prend deux arguments principaux, le nom de la colonne à séparer et un vecteur indiquant les noms des nouvelles variables à créer. Par défaut separate “sépare” au niveau des caractères non-alphanumérique (espace, symbole, etc.). On peut lui indiquer explicitement le caractère sur lequel séparer avec l’argument sep : df %&gt;% separate(eleve, c(&quot;prenom&quot;, &quot;nom&quot;), sep = &quot; &quot;) # A tibble: 3 x 3 prenom nom note * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 Félicien Machin 5/20 2 Raymonde Bidule 6/10 3 Martial Truc 87/100 11.3.4 unite : regrouper plusieurs colonnes en une seule unite est l’opération inverse de separate. Elle permet de regrouper plusieurs colonnes en une seule. Imaginons qu’on obtient le tableau d suivant : # A tibble: 6 x 4 code_departement code_commune commune pop_tot * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 01 004 Ambérieu-en-Bugey 14233 2 01 007 Ambronay 2437 3 01 014 Arbent 3440 4 01 024 Attignat 3110 5 01 025 Bâgé-la-Ville 3130 6 01 027 Balan 2785 On souhaite reconstruire une colonne code_insee qui indique le code INSEE de la commune, et qui s’obtient en concaténant le code du département et celui de la commune. On peut alors utiliser unite : d %&gt;% unite(code_insee, code_departement, code_commune) # A tibble: 6 x 3 code_insee commune pop_tot * &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 01_004 Ambérieu-en-Bugey 14233 2 01_007 Ambronay 2437 3 01_014 Arbent 3440 4 01_024 Attignat 3110 5 01_025 Bâgé-la-Ville 3130 6 01_027 Balan 2785 Le résultat n’est pas idéal : par défaut unite ajoute un caractère _ entre les deux valeurs concaténer, alors qu’on ne veut aucun séparateur. De plus, on souhaite conserver nos deux colonnes d’origine, qui peuvent nous être utiles. On peut résoudre ces deux problèmes à l’aide des arguments sep et remove : d %&gt;% unite(code_insee, code_departement, code_commune, sep = &quot;&quot;, remove = FALSE) # A tibble: 6 x 5 code_insee code_departement code_commune commune pop_tot * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; 1 01004 01 004 Ambérieu-en-Bugey 14233 2 01007 01 007 Ambronay 2437 3 01014 01 014 Arbent 3440 4 01024 01 024 Attignat 3110 5 01025 01 025 Bâgé-la-Ville 3130 6 01027 01 027 Balan 2785 11.4 Ressources Chaque jeu de données est différent, et le travail de remise en forme est souvent long et plus ou moins compliqué. On n’a donné ici que les exemples les plus simples, et c’est souvent en combinant différentes opérations qu’on finit par obtenir le résultat souhaité. Le livre R for data science, librement accessibles en ligne, contient un chapitre complet sur la remise en forme des données. L’article Tidy data, publié en 2014 dans le Journal of Statistical Software, présente de manière détaillée le concept éponyme (mais il utilise par contre des extensions désormais obsolètes qui ont été remplacées par dplyr ettidyr). Le site de l’extension est accessible à l’adresse : http://tidyr.tidyverse.org/ et contient une liste des fonctions et les pages d’aide associées. "],
["12-rmarkdown.html", "Partie 12 Exporter les résultats 12.1 Créer un nouveau document 12.2 Élements d’un document R Markdown 12.3 Personnaliser le document généré 12.4 Options des blocs de code R 12.5 Rendu des tableaux 12.6 Modèles de documents 12.7 Ressources", " Partie 12 Exporter les résultats L’extension rmarkdown permet de générer des documents de manière dynamique en mélangeant texte mis en forme et résultats produits par du code R. Les documents générés peuvent être au format HTML, PDF, Word, et bien d’autres.15 Le présent document a lui-même été généré à partir de fichiers R Markdown16 rmarkdown ne fait pas partie du tidyverse, mais elle est installée et chargée par défaut par RStudio.17 Voici un exemple de document R Markdown minimal : --- title: &quot;Test R Markdown&quot; output: word_document: default pdf_document: default html_document: default --- *R Markdown* permet de mélanger : - du texte libre mis en forme - des blocs de code R Les blocs de code sont exécutés et leur résultat affiché, par exemple : ```{r} mean(mtcars$mpg) ``` ## Graphiques On peut également inclure des graphiques : ```{r} plot(mtcars$hp, mtcars$mpg) ``` Ce document peut être “compilé” sous différents formats. Lors de cette étape, le texte est mis en forme, les blocs de code sont exécutés, leur résultat ajouté au document, et le tout est transformé dans un des différents formats possibles. Voici par exemple le rendu du document précédent au format HTML : Rendu HTML Le rendu du même document au format PDF : Rendu PDF Et le rendu au format docx : Rendu docx Les avantages de ce système sont nombreux : le code et ses résultats ne sont pas séparés des commentaires qui leur sont associés le document final est reproductible le document peut être très facilement régénéré et mis à jour, par exemple si les données source ont été modifiées. 12.1 Créer un nouveau document Un document R Markdown est un simple fichier texte enregistré avec l’extension .Rmd. Sous RStudio, on peut créer un nouveau document en allant dans le menu File puis en choisissant New file puis R Markdown…. La boîte de dialogue suivante s’affiche : Création d’un document R Markdown Elle permet d’indiquer le titre, l’auteur du document ainsi que le format de sortie par défaut (il est possible de modifier facilement ses éléments par la suite). Plutôt qu’un document classique, on peut aussi choisir de créer une présentation sous forme de slides (entrée Presentation) ou à créer un document à partir d’un modèle (Entrée From Template). Un fichier comportant un contenu d’exemple s’affiche alors. Vous pouvez l’enregistrer où vous le souhaitez avec une extension .Rmd. 12.2 Élements d’un document R Markdown Un document R Markdown est donc un fichier texte qui ressemble à quelque chose comme ça : --- title: &quot;Titre&quot; author: &quot;Prénom Nom&quot; date: &quot;10 avril 2017&quot; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` ## Introduction Ceci est un document RMarkdown, qui mélange : - du texte balisé selon la syntaxe Markdown - des bouts de code R qui seront exécutés Le code R se présente de la manière suivante : ```{r} summary(cars) ``` ## Graphiques On peut aussi inclure des graphiques, par exemple : ```{r} plot(pressure) ``` 12.2.1 En-tête (préambule) La première partie du document est son en-tête. Il se situe en tout début de document, et est délimité par trois tirets (---) avant et après : --- title: &quot;Titre&quot; author: &quot;Prénom Nom&quot; date: &quot;10 avril 2017&quot; output: html_document --- Cet en-tête contient les métadonnées du document, comme son titre, son auteur, sa date, plus tout un tas d’options possibles qui vont permettre de configurer ou personnaliser l’ensemble du document et son rendu. Ici, par exemple, la ligne output: html_document indique que le document généré doit être au format HTML. 12.2.2 Texte du document Le corps du document est constitué de texte qui suit la syntaxe Markdown. Un fichier Markdown est un fichier texte contenant un balisage léger qui permet de définir des niveaux de titres ou de mettre en forme le texte. Par exemple, le texte suivant : Ceci est du texte avec *de l&#39;italique* et **du gras**. On peut définir des listes à puces : - premier élément - deuxième élément Génèrera le texte mis en forme suivant : Ceci est du texte avec de l’italique et du gras. On peut définir des listes à puces : premier élément deuxième élément On voit que des mots placés entre des astérisques sont mis en italique, des lignes qui commencent par un tiret sont transformés en liste à puce, etc. On peut définir des titres de différents niveaux en faisant débuter la ligne par un ou plusieurs caractères # : # Titre de niveau 1 ## Titre de niveau 2 ### Titre de niveau 3 Petite astuce, si vous cliquez sur l’icône totalement à droite de la barre d’outils associée au fichier R Markdown, une table des matières dynamique générée automatiquement à partir des titres présents dans le document s’affiche et vous permet de naviguer facilement dans celui-ci : Table des matières dynamique La syntaxe Markdown permet d’autres mises en forme, comme la possibilité d’insérer des liens ou des images. Dans RStudio, le menu Help puis Markdown quick reference donne un aperçu plus complet de la syntaxe. Par exemple, le code suivant : [Exemple de lien](https://example.com) Donnera le lien suivant : Exemple de lien 12.2.3 Blocs de code R En plus du texte libre au format Markdown, un document R Markdown contient, comme son nom l’indique, du code R. Celui-ci est inclus dans des blocs (chunks) délimités par la syntaxe suivante : ```{r} x &lt;- 1:5 ``` Comme cette suite de caractères n’est pas très simple à saisir, vous pouvez utiliser le menu Insert de RStudio et choisir R,18 ou, encore mieux, d’utiliser le raccourci clavier Ctrl+Alt+i. Menu d’insertion d’un bloc de code Dans RStudio les blocs de code R sont en général affichés avec une couleur de fond légèrement différente. Quand votre curseur se trouve dans cette zone, vous pouvez saisir le code R que vous souhaitez, l’exécuter, utiliser l’autocomplétion, exactement comme si vous vous trouviez dans un script R. Vous pouvez également exécuter l’ensemble du code contenu dans un bloc à l’aide du raccourci clavier Ctrl+Shift+Entrée. Dans RStudio, par défaut, les résultats d’un bloc de code (texte, tableau ou graphique) s’affichent directement dans le document, permettant de les visualiser directement et de les conserver le temps de la session.19 Lorsque le document sera “compilé” au format HTML, PDF ou docx, chaque bloc est exécuté tour à tour, et le résultat inclus dans le document final, qu’il s’agisse de texte, d’un tableau ou d’un graphique. Les blocs sont liés entre eux, dans le sens où les données importées ou calculées dans un bloc sont accessibles aux blocs suivants. On peut donc aussi voir un document R Markdown comme un scipt R dans lequel on aurait intercalé du texte libre au format Markdown. À noter qu’avant chaque compilation, une nouvelle session R est lancée, ne contenant aucun objet. Les premiers blocs de code d’un document sont donc souvent utilisés pour importer des données, exécuter des recodages, etc. 12.2.4 Compiler un document (Knit) On peut à tout moment compiler, ou plutôt “tricoter” (Knit), un document R Markdown pour obtenir et visualiser le document généré. Pour cela, il suffit de cliquer sur le bouton Knit et de choisir le format de sortie voulu : Menu Knit Vous pouvez aussi utiliser le raccourci Ctrl+Shift+K pour compiler le document dans le dernier format utilisé. Attention : pour la génération du format PDF, vous devez avoir une installation fonctionnelle de LaTeX sur votre système. C’est en général le cas pour des ordinateurs Mac ou Linux, mais pas sous Windows : dans ce cas vous devrez installer une distribution comme MiKTeX. Un onglet R Markdown s’ouvre dans la même zone que l’onglet Console et indique la progression de la compilation, ainsi que les messages d’erreur éventuels. Si tout se passe bien, Le document devrait s’afficher soit dans une fenêtre Vihttps://miktex.org/ewer de RStudio (pour la sortie HTML), soit dans le logiciel par défaut de votre ordinateur. 12.3 Personnaliser le document généré La personnalisation du document généré se fait en modifiant des options dans le préambule du document. RStudio propose néanmoins une petite interface graphique permettant de changer ces options plus facilement. Pour cela, cliquez sur l’icône en forme d’engrenage à droite du bouton Knit et choisissez Output Options… Options de sortie R Markdown Une boîte de dialogue s’affiche vous permettant de sélectionner le format de sortie souhaité et, selon le format, différentes options : Dialogue d’options de sortie R Markdown Pour le format HTML par exemple, l’onglet General vous permet de spécifier si vous voulez une table des matières, sa profondeur, les thèmes à appliquer pour le document et la coloration syntaxique des blocs R, etc. L’onglet Figures vous permet de changer les dimensions par défaut des graphiques générés. Une option très intéressante pour les fichiers HTML, accessible via l’onglet Advanced, est l’entrée Create standalone HTML document. Si elle est cochée (ce qui est le cas par défaut), le document HTML généré contiendra en un seul fichier le code HTML mais aussi les images et toutes les autres ressources nécessaires à son affichage. Ceci permet de générer des fichiers assez volumineux, mais que vous pouvez transférer très facilement à quelqu’un par mail ou en le mettant en ligne quelque part. Si la case n’est pas cochée, les images et autres ressources sont placées dans un dossier à part. Lorsque vous changez des options, RStudio va en fait modifier le préambule de votre document. Ainsi, si vous choisissez d’afficher une table des matières et de modifier le thème de coloration syntaxique, votre en-tête va devenir quelque chose comme : --- title: &quot;Test R Markdown&quot; output: html_document: highlight: kate toc: yes --- Vous pouvez modifier les options directement en éditant le préambule. Il est possible de spécifier des options différentes selon les formats, par exemple : --- title: &quot;Test R Markdown&quot; output: html_document: highlight: kate toc: yes pdf_document: fig_caption: yes highlight: kate --- La liste complète des options possibles est présente sur le site de la documentation officielle (très complet et bien fait) et sur l’antisèche et le guide de référence, accessible depuis RStudio via le menu Help puis Cheatsheets. 12.4 Options des blocs de code R Il est également possible de passer des options à chaque bloc de code R pour modifier son comportement. On rappelle qu’on bloc de code se présente de la manière suivante : ```{r} x &lt;- 1:5 ``` 12.4.1 Nom du bloc Les options d’un bloc de code sont à placer à l’intérieur des accolades {r}. La première possibilité est de donner un nom au bloc celui-ci est passé directement après le r : {r nom_du_bloc} Il n’est pas obligatoire de donner un nom à un bloc, mais cela peut être utile en cas d’erreur à la compilation, pour identifier le bloc ayant causé le problème. Attention, on ne peut pas avoir deux blocs avec le même nom. 12.4.2 Options En plus d’un nom, on peut passer à un bloc une série d’options sous la forme option = valeur. Voici un exemple de bloc avec un nom et des options : ```{r mon_bloc, echo = FALSE, warning = TRUE} x &lt;- 1:5 ``` Et un exemple de bloc non nommé avec des options : ```{r echo = FALSE, warning = FALSE} x &lt;- 1:5 ``` Une des options la plus utile est l’option echo. Par défaut echo vaut TRUE, et le bloc de code R est inséré dans le document généré, de cette manière : x &lt;- 1:5 print(x) [1] 1 2 3 4 5 Mais si on positionne l’option echo=FALSE, alors le code R n’est plus inséré dans le document : [1] 1 2 3 4 5 Option Valeurs Description echo TRUE/FALSE Afficher ou non le code R dans le document eval TRUE/FALSE Exécuter ou non le code R à la compilation include TRUE/FALSE Inclure ou non le code R et ses résultats dans le document results “hide”/“asis”/“markup”/“hold” Type de résultats renvoyés par le bloc de code warning TRUE/FALSE Afficher ou non les avertissements générés par le bloc message TRUE/FALSE Afficher ou non les messages générés par le bloc Il existe de nombreuses autres options décrites notamment dans guide de référence R Markdown (PDF en anglais). 12.4.3 Modifier les options Il est possible de modifier les options manuellement en éditant l’en-tête du bloc de code, mais on peut aussi utiliser une petite interface graphique proposée par RStudio. Pour cela, il suffit de cliquer sur l’icône d’engrenage situé à droite sur la ligne de l’en-tête de chaque bloc : Menu d’options de bloc de code Vous pouvez ensuite modifier les options les plus courantes, et cliquer sur Apply pour les appliquer. 12.4.4 Options globales On peut vouloir appliquer une option à l’ensemble des blocs d’un document. Par exemple, on peut souhaiter par défaut ne pas afficher le code R de chaque bloc dans le document final. On peut positionner une option globalement en utilisant la fonction knitr::opts_chunk$set(). Par exemple, insérer knitr::opts_chunk$set(echo = FALSE) dans un bloc de code positionnera l’option echo=FALSE par défaut pour tous les blocs suivants. En général, on place toutes ces modifications globales dans un bloc spécial nommé setup et qui est le premier bloc du document : ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` Par défaut RStudio exécute systématiquement le contenu du bloc setup avant d’exécuter celui d’un autre bloc. 12.5 Rendu des tableaux 12.5.1 Tableaux croisés Par défaut, les tableaux issus de la fonction table sont affichés comme ils apparaissent dans la console de R, en texte brut : library(questionr) data(hdv2003) tab &lt;- lprop(table(hdv2003$qualif, hdv2003$sexe)) tab Homme Femme Total Ouvrier specialise 47.3 52.7 100.0 Ouvrier qualifie 78.4 21.6 100.0 Technicien 76.7 23.3 100.0 Profession intermediaire 55.0 45.0 100.0 Cadre 55.8 44.2 100.0 Employe 16.2 83.8 100.0 Autre 36.2 63.8 100.0 Ensemble 44.8 55.2 100.0 On peut améliorer leur présentation en utilisant la fonction kable de l’extension knitr. Celle-ci fournit un formatage adapté en fonction du format de sortie. On aura donc des tableaux “propres” que ce soit en HTML, PDF ouformats traitements de texte : library(knitr) kable(tab) Homme Femme Total Ouvrier specialise 47.29064 52.70936 100 Ouvrier qualifie 78.42466 21.57534 100 Technicien 76.74419 23.25581 100 Profession intermediaire 55.00000 45.00000 100 Cadre 55.76923 44.23077 100 Employe 16.16162 83.83838 100 Autre 36.20690 63.79310 100 Ensemble 44.82759 55.17241 100 12.5.2 Tableaux de données et tris à plat En ce qui concerne les tableaux de données, l’affichage HTML par défaut se contente d’un affichage texte comme dans la console, très peu lisible dès que le tableau dépasse une certaine dimension. Une alternative est d’utiliser la fonction paged_table, qui affiche une représentation HTML paginée du tableau : rmarkdown::paged_table(hdv2003) # A tibble: 2,000 x 20 id age sexe nivetud * &lt;int&gt; &lt;int&gt; &lt;fctr&gt; &lt;fctr&gt; 1 1 28 Femme Enseignement superieur y compris technique superieur 2 2 23 Femme NA 3 3 59 Homme Derniere annee d&#39;etudes primaires 4 4 34 Homme Enseignement superieur y compris technique superieur 5 5 71 Femme Derniere annee d&#39;etudes primaires 6 6 35 Femme Enseignement technique ou professionnel court 7 7 60 Femme Derniere annee d&#39;etudes primaires 8 8 47 Homme Enseignement technique ou professionnel court 9 9 20 Femme NA 10 10 28 Homme Enseignement technique ou professionnel long # ... with 1,990 more rows, and 16 more variables: poids &lt;dbl&gt;, # occup &lt;fctr&gt;, qualif &lt;fctr&gt;, freres.soeurs &lt;int&gt;, clso &lt;fctr&gt;, # relig &lt;fctr&gt;, trav.imp &lt;fctr&gt;, trav.satisf &lt;fctr&gt;, hard.rock &lt;fctr&gt;, # lecture.bd &lt;fctr&gt;, peche.chasse &lt;fctr&gt;, cuisine &lt;fctr&gt;, bricol &lt;fctr&gt;, # cinema &lt;fctr&gt;, sport &lt;fctr&gt;, heures.tv &lt;dbl&gt; Une autre alternative est d’utiliser kable, ou encore la fonction datatable de l’extension DT, qui propose encore davantage d’interactivité : DT::datatable(hdv2003) Dans tous les cas il est déconseillé d’afficher de cette manière un tableau de données de très grandes dimensions, car le fichier HTML résultant serait très volumineux. On peut définir un mode d’affichage par défaut pour tous les tableaux de données en modifiant les Output options du format HTML (onglet General, Print dataframes as), ou en modifiant manuellement l’option df_print de l’entrée html_document dans le préambule. À noter que les tableaux issus de la fonction freq de questionr s’affichent comme des tableaux de données (et non comme des tableaux croisés). 12.6 Modèles de documents On a vu ici la production de documents “classiques”, mais R Markdown permet de créer bien d’autres choses. Le site de documentation de l’extension propose une galerie des différentes sorties possibles. R Markdown et les extensions qui l’utilisent permettent de créer des slides, des sites Web ou même des livres entiers, comme le présent document. 12.6.1 Slides Un usage intéressant est la création de diaporamas pour des présentations sous forme de slides. Le principe reste toujours le même : on mélange texte au format Markdown et code R, et R Markdown transforme le tout en présentations au format HTML ou PDF. En général les différents slides sont séparés en fonction de certains niveaux de titre. Certains modèles de slides sont inclus avec R Markdown, notamment : ioslides et Slidy pour des présentations HTML beamer pour des présentations en PDF via LaTeX Quand vous créez un nouveau document dans RStudio, ces modèles sont accessibles via l’entrée Presentation : Créer une présentation R Markdown D’autres extensions, qui doivent être installées séparément, permettent aussi des diaporamas dans des formats variés. On citera notamment : revealjs pour des présentations HTLM basées sur le framework reveal.js rmdshower pour des diaporamas HTML basés sur shower Une fois l’extension installée, elle propose en général un template de départ lorsqu’on crée un nouveau document dans RStudio. Ceux-ci sont accessibles depuis l’entrée From Template. Créer une présentation à partir d’un template 12.6.2 Templates Il existe également différents templates permettant de changer le format et la présentation des documents générés. Une liste de ces formats et leur documentation associées est accessible depuis la page formats de la documentation. On notera notamment : des formats d’article correspondant à des publications dans différentes revues : jss_article, elsevier_article, etc. le format Tufte Handouts qui permet de produire des documents PDF ou HTML dans un format proche de celui utilisé par Edward Tufte pour certaines de ses publications Enfin, l’extension rmdformats propose plusieurs modèles HTML adaptés notamment pour des documents longs : Modèle readthedown Modèle html_clean Modèle material Là encore, la plupart du temps, ces modèles de documents proposent un template de départ lorsqu’on crée un nouveau document dans RStudio (entrée From Template) : Créer un document à partir d’un template 12.7 Ressources Les ressources suivantes sont toutes en anglais… L’ouvrage R for data science, accessible en ligne, contient un chapitre dédié à R Markdown. Le site officiel de l’extension contient une documentation très complète, tant pour les débutants que pour un usage avancé. Enfin, l’aide de RStudio (menu Help puis Cheatsheets) permet d’accéder à deux documents de synthèse : une “antisèche” synthétique (R Markdown Cheat Sheet) et un “guide de référence” plus complet (R Markdown Reference Guide). On peut citer les formats odt, rtf, Markdown, etc.↩ Plus précisément grâce à l’extension bookdown qui permet de générer des documents de type livre.↩ Si vous n’utilisez pas ce dernier, l’extension peut être installée à part avec install.packages(&quot;rmarkdown&quot;) et chargée explicitement avec library(rmarkdown)↩ Il est possible d’inclure dans un document R Markdown des blocs de code d’autres langages↩ Ce comportement peut être modifié en cliquant sur l’icône d’engrenage de la barre d’outils et en choisissant Chunk Output in Console↩ "],
["13-ressources.html", "A Ressources A.1 Aide A.2 Ouvrages, blogs, MOOCs… A.3 Extensions", " A Ressources A.1 Aide A.1.1 Aide de R et RStudio Il est possible d’obtenir à tout moment de l’aide (en anglais) sur une fonction en tapant help() avec comme argument le nom de la fonction dans la console : help(&quot;mean&quot;) Vous pouvez aussi aller dans l’onglet Help de l’interface de RStudio (dans le quart de l’écran en bas à droite) et utiliser le moteur de recherche intégré. Chaque page d’aide est très complète mais pas toujours très accessible. Elle est structurée selon différentes sections, notamment : Description donne un résumé en une phrase de ce que fait la fonction Usage indique la ou les manières de l’utiliser Arguments détaille les arguments possibles et leur signification Value indique la forme du résultat renvoyé par la fonction Details apporte des précisions sur le fonctionnement de la fonction See Also renvoit vers d’autres fonctions semblables ou liées, ce qui peut être très utile pour découvrir ou retrouver une fonction dont on a oublié le nom Examples donne une série d’exemples d’utilisation Les exemples d’une page d’aide peuvent être exécutés directement dans la console avec la fonction example : example(&quot;mean&quot;) mean&gt; x &lt;- c(0:10, 50) mean&gt; xm &lt;- mean(x) mean&gt; c(xm, mean(x, trim = 0.10)) [1] 8.75 5.50 L’onglet Help de RStudio permet d’afficher mais aussi de naviguer dans les pages d’aide de R et dans d’autres ressources. Onglet Help de Rstudio Cette page permet d’accéder aux manuels officiels de R (section Manuals), qui abordent différents aspects plus ou moins techniques du langage et du logiciel, en anglais. On citera notamment les documents An Introduction to R et R Data Import/Export. Elle propose également un lien vers la FAQ officielle. A.1.2 Aide en ligne Plusieurs sites proposent une interface permettant de naviguer et rechercher dans l’aide de R et de l’ensemble des extensions existantes. On notera notamment : RDocumentation rrdr.io A.1.3 Où poser des questions Outre l’aide intégrée au logiciel, il existe de nombreuses ressources en ligne, forums, listes de discussions, pour poser ses questions et échanger avec des utilisateurs de R. A.1.3.1 Listes de discussion La liste R-soc est une liste francophone spécialement dédiée aux utilisateurs de R en sciences sociales. Toutes les questions y sont les bienvenues, et les réponses sont en général assez rapide. Il suffit de s’y abonner pour pouvoir ensuite poster sa question : https://groupes.renater.fr/sympa/subscribe/r-soc La liste semin-r est la liste de discussion du groupe des utilisateurs de R animé par le Muséum national d’Histoire naturelle. Elle est ouverte à tous et les questions y sont bienvenues : https://listes.mnhn.fr/wws/subscribe/semin-r Il existe aussi une liste officielle anglophone baptisée R-help. Elle est cependant à réserver aux questions les plus pointues, et dans tous les cas il est nécessaire d’avoir en tête et de respecter les bonnes pratiques avant de poster sur la liste : https://stat.ethz.ch/mailman/listinfo/r-help A.1.3.2 Sur le Web Pour les anglophones, la ressource la plus riche concernant R est certainement le site StackOverflow. Sous forme de questions/réponses, il comporte un très grand nombre d’informations sur R et les réponses y sont très rapides. Avant de poster une question il est fortement recommandé de faire une recherche sur le site : il y a de fortes chances que celle-ci ait déjà été posée : https://stackoverflow.com/questions/tagged/r Parmi les francophones, on pourra citer le forum du CIRAD, qui comporte une section questions en cours assez active. Là aussi, pensez à faire une recherche sur le forum avant de poser votre question : http://forums.cirad.fr/logiciel-R/ A.2 Ouvrages, blogs, MOOCs… A.2.1 Francophones Parmi les ressources en français, on peut citer notamment R et espace, manuel d’initiation à la programmation avec R appliqué à l’analyse de l’information géographique, librement téléchargeable en ligne. La section Contributed documentation du site officiel de R contient également des liens vers différents documents en français, plus ou moins accessibles et plus ou moins récemment mis à jour. Le pôle bioinformatique lyonnais (PBIL) propose depuis longtemps une somme très importante de documents, qui comprend des cours complets de statistiques utilisant R : http://pbil.univ-lyon1.fr/R/ Plusieurs blogs francophones autour de R sont également actifs, parmi lesquels : ElementR, le blog du groupe du même nom, qui propose de nombreuses ressources sur R en général et en particulier sur la cartogrpahie ou l’analyse de réseaux. R-atique, blog animé par Lise Vaudor, propose régulièrement des articles intéressants et accessibles sur des méthodes d’analyse ou sur des extensions R. Enfin, le site France Université Numérique propose régulièrement des sessions de cours en ligne, parmi lesquels une Introduction à la statistique avec R et une introduction à l’Analyse des données multidimensionnelles. A.2.2 Anglophones Les ressources anglophones sont évidemment très nombreuses. On citera essentiellement l’ouvrage en ligne R for data science, très complet, et qui fournit une introduction très complète et progressive à R, et aux packages du tidyverse. Il existe également en version papier. Pour aborder des aspects beaucoup plus avancés, l’ouvrage également en ligne Advanced R, d’Hadley Wickham, est extrêmement bien et fait et très complet. On notera également l’existence du R journal, revue en ligne consacrée à R, et qui propose régulièrement des articles sur des méthodes d’analyse, des extensions, et l’actualité du langage. A.3 Extensions A.3.1 Où trouver des extensions intéressantes ? Il existe plusieurs milliers d’extensions pour R, et il n’est pas toujours facile de savoir laquelle choisir pour une tâche donnée. Si un des meilleurs moyens reste le bouche à oreille, on peut aussi se reporter à la page CRAN Task view qui liste un certain nombre de domaines (classification, sciences sociales, séries temporelles) et indique, pour chacune d’entre elles, une liste d’extensions potentiellement intéressantes accompagnées d’une courte description. On peut même installer l’ensemble des extensions d’une catégorie avec la fonction install.views(). Un autre site intéressant est Awesome R, une liste élaborée collaborativement des extensions les plus utiles ou les plus populaires classées par grandes catégories : manipulation des données, graphiques interactifs, etc. Enfin, certaines extensions fournissent des “galeries” permettant de repérer ou découvrir certains packages. C’est notamment le cas de htmlwidgets, qui propose une galerie d’extensions proposant des graphiques interactifs, ou de R Markdown. A.3.2 L’extension questionr questionr est une extension utilisée régulièrement dans ce document et comprenant quelques fonctions potentiellement utiles pour l’utilisation du logiciel en sciences sociales, ainsi que différents jeux de données. Elle est développée en collaboration avec François Briatte et Joseph Larmarange. L’installation se fait soit via le bouton Install de l’onglet Packages de RStudio, soit en utilisant la fonction suivante dans la console : install.packages(&quot;questionr&quot;) Il est possible d’installer la version de développement à l’aide de la fonction install_github de l’extension devtools : devtools::install_github(&quot;juba/questionr&quot;) questionr propose à la fois des fonctions utiles, des interfaces interactives et des jeux de données d’exemple. A.3.2.1 Fonctions et utilisation Pour plus de détails sur la liste des fonctions de l’extension et son utilisation, on pourra se reporter au site Web de l’extension, hébergé sur GitHub. L’onglet Reference liste l’ensemble des fonctions de questionr, tandis que l’onglet Articles propose une présentation des trois interfaces interactives (Addins) visant à faciliter le recodage de certaines variables. Ces interfaces sont également abordées dans la partie @ref(vector_factor). A.3.2.2 Jeu de données hdv2003 hdv2003 est un extrait comportant 2000 individus et 20 variables provenant de l’enquête Histoire de Vie réalisée par l’INSEE en 2003. L’extrait est tiré du fichier détail mis à disposition librement (ainsi que de nombreux autres) par l’INSEE. On trouvera une documentation complète à la même adresse. Les variables retenues ont été parfois partiellement recodées. La liste des variables est la suivante : Variable Description id Identifiant (numéro de ligne) poids Variable de pondération age Âge sexe Sexe nivetud Niveau d’études atteint occup Occupation actuelle qualif Qualification de l’emploi actuel freres.soeurs Nombre total de frères, sœurs, demi-frères et demi-sœurs clso Sentiment d’appartenance à une classe sociale relig Pratique et croyance religieuse trav.imp Importance accordée au travail trav.satisf Satisfaction ou insatisfaction au travail hard.rock Ecoute du Hard rock ou assimilés lecture.bd Lecture de bandes dessinées peche.chasse Pêche ou chasse pour le plaisir au cours des 12 derniers mois cuisine Cuisine pour le plaisir au cours des 12 derniers mois bricol Bricolage ou mécanique pour le plaisir au cours des 12 derniers mois cinema Cinéma au cours des 12 derniers mois sport Sport ou activité physique pour le plaisir au cours des 12 derniers mois heures.tv Nombre moyen d’heures passées àregarder la télévision par jour ote :* Comme il s’ agit d’un extrait du fichier, la variable de pondération n’a en toute rigueur aucune valeur statistique. Elle a été tout de même incluse à des fins “pédagogiques”. A.3.2.3 Jeu de données rp2012 rp2012 est un jeu de données issu du recensement de la population de 2012 de l’INSEE. Il comporte une petite partie des résultats pour l’ensemble des communes de plus de 2000 habitants de France métropolitaine. Il comporte 5170 communes et 60 variables. Liste de quelques variables du fichier : Variable Description commune nom de la commune code_insee Code de la commune pop_tot Population total pop_act_15p Population active de 15 ans et plus log_rp Nombre de résidences principales agric Part des agriculteurs dans la population active indep Part des artisans, commerçants et chefs d’entreprises cadres Part des cadres interm Part des professions intermédiaires empl Part des employés ouvr Part des ouvriers chom Part des chômeurs etud Part des étudiants dipl_sup Part des diplômés du supérieur dipl_aucun Part des personnes sans diplôme proprio Part des propriétaires parmi les résidences principales hlm Part des logements HLM parmi les résidences principales locataire Part des locataires parmi les résidences principales maison Part des maisons parmi les résidences principales "],
["14-references.html", "B References", " B References "]
]
